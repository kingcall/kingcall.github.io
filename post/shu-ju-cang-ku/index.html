<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>数据仓库 | Welcome to Kingcall&#39;s GitHub Pages</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kingcall.github.io/favicon.ico?v=1597759865338">
<link rel="stylesheet" href="https://kingcall.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="

数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。
企业需要对不同来源、不同形式、不..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kingcall.github.io">
        <img src="https://kingcall.github.io/images/avatar.png?v=1597759865338" class="site-logo">
        <h1 class="site-title">Welcome to Kingcall&#39;s GitHub Pages</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/bigdata" class="site-nav">
            大数据
          </a>
        
      
        
          <a href="/design" class="site-nav">
            软件设计
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      生命不息 奋斗不止
    </div>
    <div class="site-footer">
      Welcome to Kingcall's GitHub Pages | <a class="rss" href="https://kingcall.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">数据仓库</h2>
            <div class="post-date">2020-08-18</div>
            
            <div class="post-content" v-pre>
              <!-- more -->
<ul>
<li>数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。</li>
<li>企业需要对不同来源、不同形式、不同主题的数据整合起来，供给数据分析、数据挖掘、数据报表使用时，有这么一个中间层将各种原始数据科学地加工处理成下游需要的样子。<strong>这个中间层就是数据仓库产生价值的地方</strong></li>
</ul>
<h2 id="建模流程">建模流程</h2>
<h3 id="业务建模">业务建模</h3>
<ul>
<li>根据业务部门进行划分，理清部门之间的关系，然后将<strong>各个部门的具体业务程序化</strong>，与业务部门开会<strong>协商出需求的指标、保存年限、维度</strong>等等。</li>
<li>总体来讲，就是要<strong>知道他们需要哪些指标以及他们能提供哪些数据</strong>。</li>
<li>业务建模的时间最长，而且与公司实际的业务环境息息相关，因此在这里需要根据实际生产环境和业务需求确认好数据仓库使用的工具和平台。</li>
</ul>
<h3 id="概念建模">概念建模</h3>
<ul>
<li><strong>将业务模型抽象化，分组合并类似的概念，细化概念</strong>，抽象出实体与实体之间的联系，理清各组概念之间的联系。</li>
<li>说白了就是画图，把指标需要的哪些数据封装到一个实体里，实体与实体之间的关联等等用ER图表示出来。</li>
<li>先画出局部ER图，最后再综合画出全局ER图。</li>
</ul>
<h3 id="逻辑建模">逻辑建模</h3>
<ul>
<li>将概念模型实体化，具体考虑概念对应的属性，事件考虑事实属性，维度考虑维度属性。</li>
<li>总体来说就是建表，前面已经画出了关系图，这里只要将表里头有哪些字段考虑出来就可以，如果是事实表就考虑事实字段和业务主键，如果是维度表就考虑维度属性，SCD策略等等。在这里需要确定数据粒度，如果多个指标都用到一个字段，则取粒度最小的指标。如果不确定指标的量度，则取毫秒级作为粒度。</li>
</ul>
<h3 id="物理建模">物理建模</h3>
<ul>
<li>综合现实的大数据平台、采集工具、etl工具、数仓组件、性能要求、管理要求等多方面因素，设计出具体的项目代码，完成数仓的搭建。</li>
</ul>
<h2 id="建模方法论">建模方法论</h2>
<ol>
<li><strong>访问性能</strong>：能够快速查询所需的数据，减少数据I/O。<br>
1.** 数据成本**：减少不必要的数据冗余，实现计算结果数据复用，降低大数据系统中的存储成本和计算成本。</li>
<li><strong>使用效率</strong>：改善用户应用体验，提高使用数据的效率。</li>
<li><strong>数据质量</strong>：改善数据统计口径的不一致性，减少数据计算错误的可能性，提供高质量的、一致的数据访问平台。</li>
</ol>
<blockquote>
<p>需要注意的建模其实是和公司的业务、公司的数据量、公司使用的工具、公司数据的使用方式密不可分的</p>
</blockquote>
<h3 id="范式建模关系型数据库">范式建模(关系型数据库)</h3>
<ul>
<li>范式建模法其实是我们在构建数据模型常用的一个方法，该方法的主要由Inmon所提倡，主要解决关系型数据库得数据存储，利用的一种技术层面上的方法，主要用于业务系统，<strong>所以范式建模主要是利用关系型数据库进行数仓建设</strong></li>
<li>目前，我们在关系型数据库中的建模方法，大部分采用的是三范式建模法。</li>
<li>符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>
</ul>
<h4 id="三范式">三范式</h4>
<h5 id="第一范式">第一范式</h5>
<ul>
<li>属性值不可再分</li>
</ul>
<h5 id="第二范式">第二范式</h5>
<ul>
<li>要求每张表都要有一个主键，其它记录完全依赖主键。要求实体的属性<strong>完全依赖于主关键字</strong>。</li>
</ul>
<blockquote>
<p>例如，如果花名册里只有名字，没有学号，则重名的话会很麻烦。</p>
</blockquote>
<ul>
<li>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。</li>
</ul>
<h5 id="第三范式">第三范式</h5>
<ul>
<li>所有字段只能依赖主键，不得依赖于其它字段(非主属性)。消除依赖传递。</li>
</ul>
<h4 id="范式建模的优缺点">范式建模的优缺点</h4>
<h5 id="优点">优点</h5>
<ul>
<li>节约存储(尤其是利用数据库进行数仓建设的时候)</li>
<li>结构清晰，易于理解</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>构建比较复杂</li>
<li>查询复杂(需要很多的关联)</li>
<li>不适合在大数据环境下构建(1 查询复杂  2 存储很便宜)</li>
</ul>
<h4 id="为什么还要学习范式建模">为什么还要学习范式建模</h4>
<ul>
<li>上游数据源往往是业务数据库，而这些业务数据库采用的实范式建模，所以了解范式建模可以帮助我们去合理的建设数仓</li>
</ul>
<blockquote>
<p>如果了解范式建模，从er 模型可以了解到数据架构，例如一个电商系统，从er模型就可以知道哪些涉及到商品的管理、用户的管理、订单管理，拿到这些关系之后，我们就可以更好的进行数仓管理与建设</p>
</blockquote>
<ul>
<li>数据源的规范定义需要我们了解范式理论，可以更好的和业务系统进行对接</li>
<li>数仓的稀有系统，如报表系统设计的时候也会使用到范式建模</li>
</ul>
<h3 id="er实体建模">ER实体建模</h3>
<ul>
<li>将事务抽象为&quot;实体&quot;（Entity）、&quot;属性&quot;（Property）、&quot;关系&quot;（Relationship）来<strong>表示数据关联和事物描述</strong>，这种<strong>对数据的抽象建模</strong>通常被称为ER实体关系模型。</li>
<li>实体建模法并不是数据仓库建模中常见的一个方法，它来源于哲学的一个流派。</li>
<li>从哲学的意义上说，客观世界应该是可以细分的，客观世界应该可以分成由一个个实 体，以及实体与实体之间的关系组成。我们在数据仓库的建模过程中完全可以引入这个抽象的方法，<strong>将整个业务也可以划分成一个个的实体，而每个实体之间的 关系，以及针对这些关系的说明就是我们数据建模需要做的工作</strong>。</li>
<li></li>
</ul>
<blockquote>
<p>在日常建模中，&quot;实体&quot;用矩形表示，&quot;关系&quot;用菱形，&quot;属性&quot;用椭圆形。ER实体关系模型也称为E-R关系图</p>
</blockquote>
<blockquote>
<p>虽然实体法粗看起来好像有一些抽象，其实理解起来很容易。即我们可以将任何一个业务过程划分成 3 个部分，实体，事件和说明。<br>
描述一个简单的事实：“小明开车去学校上学”。以这个业务事实为例，我们可以把“小明”，“学校”看成是一个实体， “上学”描述的是一个业务过程，我们在这里可以抽象为一个具体“事件”，而“开车去”则可以看成是事件“上学”的一个说明。</p>
</blockquote>
<h4 id="应用场景">应用场景</h4>
<ul>
<li><strong>ER模型是数据库设计的理论基础，当前几乎所有的OLTP系统设计都采用ER模型建模的方式</strong>。</li>
<li>Bill Inom提出的数仓理论，推荐采用ER关系模型进行建模。</li>
<li>BI架构提出分层架构，数仓底层ods、dwd也多采用ER关系模型进行设计。</li>
</ul>
<blockquote>
<p>由于实体建模法，能够很轻松的实现业务模型的划分，因此，在业务建模阶段和领域概念建模阶段，实体建模法有着广泛的应用。</p>
</blockquote>
<h4 id="业务归纳">业务归纳</h4>
<blockquote>
<p>使用的抽象归纳方法其实很简单，任何业务可以看成 3 个部分：</p>
</blockquote>
<ol>
<li>实体，主要指领域模型中特定的概念主体，指发生业务关系的对象</li>
<li>事件，主要指概念主体之间完成一次业务流程的过程，特指特定的业务过程</li>
<li>说明，主要是针对实体和事件的特殊说明</li>
</ol>
<h3 id="维度建模">维度建模</h3>
<blockquote>
<p>维度建模源自数据集市，主要面向分析场景。RalphKimball推崇数据集市的集合为数据仓库，同时也提出了对数据集市的维度建模，将数据仓库中的表划分为事实表、维度表两种类型。</p>
</blockquote>
<ul>
<li>般也称之为星型结构建模，有时也加入一些雪花模型在里面。维度建模是一种面向用户需求的、容易理解的、访问效率高的建模方法</li>
<li>以事实表和维度表组成的星型数据模型</li>
</ul>
<h4 id="事实表">事实表</h4>
<ul>
<li>在ER模型中抽象出了有<strong>实体、关系、属性</strong>三种类别，<strong>在现实世界中，每一个操作型事件，基本都是发生在实体之间的</strong>，伴随着这种操作事件的发生，会产生<strong>可度量的值</strong>，而<strong>这个过程就产生了一个事实表，存储了每一个可度量的事件</strong></li>
<li>可以认为是<strong>主题的各个度量</strong><br>
&quot;昨天早上张三在京东花费200元买了一个皮包&quot;,这里以购买为主题(过程)的话，200就是针对该过程(主题)的一个度量，所以可以看出事实表示包含了维度表的主键，这个时候就需要通过join 进行关联，<strong>在关联的过程中引入了雪花模型和星型模型以及星座模型</strong></li>
<li><strong>事实表的特点就是增长迅速，且主要以数值进行记录</strong></li>
</ul>
<h5 id="事实表的度量">事实表的度量</h5>
<ul>
<li>可加</li>
</ul>
<blockquote>
<p>可以进行任意维度下的累加</p>
</blockquote>
<ul>
<li>半可加</li>
</ul>
<blockquote>
<p>每个学生的各个科目的成绩是可加的，但是全班的各个科目进行累加是没有意义的</p>
</blockquote>
<ul>
<li>不可加</li>
<li>需要注意不可加的在任何情况下都是不可加的，比例或者比率是只针对该行有意义，直接累加无意义</li>
</ul>
<h5 id="一致性">一致性</h5>
<h6 id="内部一致性">内部一致性</h6>
<ul>
<li>在同一个表中，所有记录的粒度和维度是一致的，每一列的单位、枚举值都是一样的</li>
</ul>
<blockquote>
<p>想想掌门的学生课程表，少儿和一对一属于两个业务线，放在一起之后字段都无法统一</p>
</blockquote>
<blockquote>
<p>例如 订单表中的金额的单位要进行统一，不能有的是分，有的是元</p>
</blockquote>
<h6 id="表与表之间的一致性">表与表之间的一致性</h6>
<ul>
<li>在进行多表合并的时候要保证彼此之间是针对同一事实的计算，是在同一粒度和维度之下的</li>
</ul>
<blockquote>
<p>订单表和退单表进行对冲，我们需要保证维度是一致的，例如可以设置订单表的金额是正的，退单表的金额是负的，然后合并分组求和即可。</p>
</blockquote>
<h5 id="事实表设计原则">事实表设计原则</h5>
<ol>
<li>尽可能包括所有业务过程相关的事实</li>
<li>只选择与业务过程相关的事实</li>
<li>分解不可加事实为可加的组件</li>
<li>选择维度和事实之前必须先声明粒度</li>
<li>在同一个事实表中不可以有多重不同粒度的事实</li>
<li>事实的单位要保持一致</li>
<li>对事实的null值要处理</li>
<li>使用退化维提高事实表的易用性</li>
</ol>
<h4 id="维度表">维度表</h4>
<ul>
<li>维度，顾名思义，<strong>看待事物的角度，可以认为是主题的各个属性</strong>，可以认为是对分析主题所属类型的描述。</li>
</ul>
<blockquote>
<p>&quot;昨天早上张三在京东花费200元买了一个皮包&quot;,这里分析时间维度、地点维度(京东)、商品维度(皮包)</p>
</blockquote>
<ul>
<li>维度表一般为<strong>单一主键</strong>，在ER模型中，实体为客观存在的事务，会带有自己的描述性属性，属性一般为文本性、描述性的，这些描述被称为维度。</li>
<li>维度建模的核心是<strong>数据可以抽象为事实和维度</strong>，维度即观察事物的角度，事实某一粒度下的度量词</li>
</ul>
<h5 id="维度表设计">维度表设计</h5>
<ul>
<li>维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成维度属性的优劣，决定了维度是用的方便性，成为数据仓库易用性的关键。</li>
<li><strong>数据仓库的能力直接与维度属性的质量和深度成正比</strong>。</li>
</ul>
<h5 id="维度表基本设计方法">维度表基本设计方法</h5>
<ul>
<li>第一步：选择维度(在已有的维度上进行添加)或者新建维度。作为维度建模的核心，<strong>在企业级数据仓库中，必须保证维度的唯一性。以商品维度为例，有且只有一个维度定义</strong>。</li>
<li>第二步：确定主维表。此处的主维表一般是ODS表，直接与业务系统同步。</li>
<li>第三步：确定相关维表。数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性，根据业务系统的梳理，确定哪些表和主维表存在关联关系，并选择其中的某些表用于生成维度属性。以商品维度为例，根据业务逻辑的梳理，可以得到商品与类目、sku、买家、卖家、店铺等维度存在的关联关系- 第四步：确定维度属性。本步骤主要包括两个阶段，其中一个阶段是从主维表中选择维度属性或生成新的维度属性；第二个阶段是从相关维表中选择维度属性或者生成新的维度属性。以商品维度为例，从主维表和类目、sku、卖家、店铺等相关维表中选择维度属性或者生成新的维度属性</li>
</ul>
<h5 id="缓慢变化维度表">缓慢变化维度表</h5>
<h6 id="重写维度值">重写维度值</h6>
<ul>
<li>采用此种方式，不保留历史数据（简单来说就是更新相关的维度字段）</li>
</ul>
<h5 id="建议">建议</h5>
<ul>
<li>尽可能生成丰富的维度属性；</li>
<li>尽可能多的给出包括一些富有意义的文字描述；</li>
<li>区分数值型属性和事实；</li>
<li>尽可能沉淀出通用的维度属性。</li>
</ul>
<h4 id="模型实现">模型实现</h4>
<ul>
<li>模型主要是源于维度建模过程中，需要对维度表和事实表进行关联的设计。</li>
<li>星型模型和雪花模型的<strong>主要区别在于对维度表的拆分</strong>，<strong>对于雪花模型，维度表的设计更加规范，一般符合3NF</strong>；而<strong>星型模型，一般采用降维的操作，利用冗余来避免模型过于复杂，提高易用性和分析效率</strong>。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="97754E015F1E4D56981C6458BE1B698A" alt="image" loading="lazy"></figure>
<h5 id="雪花模型">雪花模型</h5>
<ul>
<li>星形模式中的维表相对雪花模式来说要大，而且不满足规范化设计。</li>
<li>雪花模型相当于将星形模式的大维表拆分成小维表，满足了规范化设计。然而这种模式在实际应用中很少见，因为这样做会导致开发难度增大，而数据冗余问题在数据仓库里并不严重</li>
<li>可以认为雪花模型是星型模型的一个扩展，每个维度表可以继续向外扩展，连接多个子维度。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="E5EE03DD106F49F2ACE0EB5E751C2D37" alt="image" loading="lazy"></figure>
<h5 id="星型模型">星型模型</h5>
<blockquote>
<p>核心是<strong>一个事实表及多个非正规化描述的维度表</strong>组成，维度表之间是没有关联的，维度表是直接关联到事实表上的</p>
</blockquote>
<ul>
<li>只有当维度表极大，存储空间是个问题时，才考虑雪花型维度，简而言之，最好就用星型维度即可</li>
</ul>
<figure data-type="image" tabindex="3"><img src="246E01B16D424438A25DCCD45D886737" alt="image" loading="lazy"></figure>
<h5 id="星座模型">星座模型</h5>
<figure data-type="image" tabindex="4"><img src="D7C4975ECC40406B8604F687F7404CD2" alt="image" loading="lazy"></figure>
<ul>
<li>前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在业务发展后期，绝大部分维度建模都采用的是星座模式。</li>
<li>可以认为是多个事实表的关联或者是星型模型的关联，其实到了业务发展后期都是星座模型</li>
</ul>
<h4 id="应用场景-2">应用场景</h4>
<ul>
<li>维度建模<strong>是面向分析场景而生</strong>，针对分析场景构建数仓模型，重点关注快速、灵活的解决分析需求，同时能够提供大规模数据的快速响应性能。</li>
<li>针对性强，主要应用于数据仓库构建和OLAP引擎底层数据模型</li>
</ul>
<h4 id="建模的过程">建模的过程</h4>
<ul>
<li>假设我们现在在构建一张订单表</li>
</ul>
<blockquote>
<p>从多个维度进行统计组合，形成多维度数据集，来从多个角度观察业务过程的好坏</p>
</blockquote>
<h5 id="选择业务过程">选择业务过程</h5>
<ul>
<li>业务过程就是需要那<strong>种业务场景下</strong>产生的订单表(划分到那个业务线和数据域)</li>
<li>业务过程就是用户下单的订单记录表</li>
</ul>
<h5 id="申明粒度">申明粒度</h5>
<ul>
<li>粒度就是确认一条记录代表的含义或者是细化到何种程度(一条记录代表一个订单还是多个订单，如拼团的时候团长的单)</li>
<li>一条记录代表一个有效的订单</li>
</ul>
<h5 id="确认维度">确认维度</h5>
<ul>
<li>维度指的是该订单有哪些附属信息，比如订单的类型、支付方式、城市信息、日期信息</li>
<li>商品的维度、用户的维度、支付维度、收货维度、城市维度、日期维度</li>
</ul>
<h5 id="确认事实">确认事实</h5>
<ul>
<li>实时指的是订单的度量数值</li>
<li>订单的金额</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<h5 id="优点-2">优点</h5>
<ul>
<li>方便使用</li>
<li>适合大数据下的处理操作(其实就是shuffle)</li>
<li>适合OLAP操作(上钻下钻)</li>
</ul>
<h5 id="缺点-2">缺点</h5>
<ul>
<li>维度补全后造成的数据浪费</li>
<li>维度变化造成的数据更新量大(例如刷数据的时候，需要刷大量的表)</li>
<li>与典型的范式理论差异很大</li>
</ul>
<blockquote>
<p>既然如此为什么还要使用范式建模呢，其实和我们使用的工具有关系</p>
</blockquote>
<h3 id="分层建设理论">分层建设理论</h3>
<h4 id="分层的意义">分层的意义</h4>
<h5 id="清晰数据结构">清晰数据结构</h5>
<ul>
<li>每一个数据分层都有它的作用域，这样在使用表的时候能更方便的定位和理解。</li>
</ul>
<h5 id="数据血缘追踪">数据血缘追踪</h5>
<ul>
<li>由于最终给业务呈现的是一个能直接使用的业务表，但是表的数据来源有很多，如果有一张来源表出问题了，我们希望能够<strong>快速准确的定位到问题，并清楚他的危害范围和影响范围</strong>。</li>
</ul>
<h5 id="减少重复开发和资源浪费">减少重复开发和资源浪费</h5>
<ul>
<li>规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算</li>
<li>清晰明了的结构使得开发、维护的成本降低</li>
<li>减少重复计算和存储的资源浪费</li>
</ul>
<h5 id="复杂问题简单化">复杂问题简单化</h5>
<ul>
<li>将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。</li>
</ul>
<blockquote>
<p>在实际的建设过程中，由于业务使用数据非常紧急以及统一数仓层建设跟不上业务的需要，所以DIM和ADS层可能直接使用ODS层进行快速的业务响应，但是这种不规范的操作可能导致数据口径不一致，<strong>所以待数仓建设完毕，要切换到统一数仓层和DIM层</strong></p>
</blockquote>
<h4 id="ods">ods</h4>
<ul>
<li>ODS 全称是 OperationalDataStore，操作数据存储&quot;面向主题的&quot;，数据运营层，也叫ODS层，是最接近数据源中数据的一层，数据源中的数据，经过抽取、洗净、传输，也就说传说中的 ETL 之后，装入本层。</li>
<li>本层的数据，总体上大多是<strong>按照源头业务系统的分类方式而分类的</strong>。</li>
</ul>
<blockquote>
<p>但是，这一层面的数据却不等同于原始数据。在源数据装入这一层时，要进行诸如<strong>去噪</strong>(例如有一条数据中人的年龄是300岁，这种属于异常数据，就需要提前做一些处理)、去重(例如在个人资料表中，同一ID却有两条重复数据，在接入的时候需要做一步去重)、字段命名规范等一系列操作</p>
</blockquote>
<ul>
<li>这里的数据处理，并不涉及业务逻辑，仅仅是针对数据完整性以及重复值和空值的处理。</li>
</ul>
<h5 id="设计规范">设计规范</h5>
<ul>
<li>表名的设计 ODS_业务系统_表名，这样的设计可以保持与业务表名一致，又可以有清晰的层次，还可以区分来源。</li>
<li>ods 层<strong>不做字段名归一和字段类型统一的操作，如果需要使用兼容的数据类型</strong></li>
<li>对于增量表，需要设计增量表(ODS_业务系统_表名_delta)和全量表,然后将增量表合并成全量表数据</li>
<li>对于半结构化数据需要设计解析</li>
<li>由于业务数据库（OLTP）基本按照ER实体模型建模，因此ODS层中的建模方式也是<strong>ER实体模型</strong></li>
</ul>
<blockquote>
<p>ods 的设计可以保证所有的数据按照统一的规范进行存储。</p>
</blockquote>
<h4 id="统一数仓层dw">统一数仓层(DW)</h4>
<ul>
<li>是数据仓库的主体.在这里，从ODS层中获得的数据按照主题建立各种数据模型。</li>
<li>这一层和维度建模会有比较深的联系，业务数据是按照<strong>业务流程方便操作的角度</strong>来组织数据的，而统一数仓层是<strong>按照业务易理解的角度</strong>进行数据组织的。</li>
<li>定义了一致的指标、维度，各业务板块、数据域都是按照统一的规范来建设，从而形成统一规范的<strong>标准业务数据体系</strong></li>
<li>它们通常都是基于Kimball的维度建模理论来构建的，<strong>并通过一致性维度和数据总线来保证各个子主题的维度一致性</strong>。</li>
</ul>
<blockquote>
<p>如果 ods 层的数据就非常规整，基本能满足我们绝大部分的需求，这当然是好的，这时候dwd层其实也没太大必要。但是现实中接触的情况是 ods 层的数据很难保证质量，毕竟数据的来源多种多样，推送方也会有自己的推送逻辑，在这种情况下，我们就需要通过额外的一层 dwd 来屏蔽一些底层的差异。</p>
</blockquote>
<h5 id="设计原则">设计原则</h5>
<h6 id="一致性维度规范">一致性维度规范</h6>
<ul>
<li>公共层的维度表中相同维度属性在不同物理表中的字段名称、数据类型、数据内容必须保持一致</li>
</ul>
<h6 id="维度的组合与拆分">维度的组合与拆分</h6>
<ul>
<li>将维度所描述业务相关性强的字段在一个物理维表实现。相关性强是指经常需要一起查询或进行报表展现、两个维度属性间是否存在天然的关系等。例如，商品基本属性和所属品牌。</li>
</ul>
<h5 id="dwd">DWD</h5>
<ul>
<li>公告明细数据层</li>
<li>DWD层要做的就是将<strong>数据清理、整合、规范化、脏数据、垃圾数据、规范不一致的、状态定义不一致的、命名不规范的数据都会被处理</strong>。</li>
<li>DWD层应该是覆盖所有系统的、完整的、干净的、具有一致性的数据层。在DWD层会根据维度模型，设计事实表和维度表，也就是说DWD层是一个非常规范的、高质量的、可信的数据明细层。</li>
</ul>
<h5 id="dws">DWS</h5>
<ul>
<li>DWS层为<strong>公共汇总层</strong>，会进行轻度汇总，粒度比明细数据稍粗，<strong>基于DWD层上的基础数据，整合汇总成分析某一个主题域的服务数据</strong>，一般是宽表。</li>
<li>DWS层应覆盖80%的应用场景</li>
</ul>
<h4 id="dim-层">DIM 层</h4>
<ul>
<li>维表层</li>
<li>稳定维度维表，渐变维度维表</li>
</ul>
<h5 id="维度表-2">维度表</h5>
<ul>
<li><strong>维度指的是观察事物的角度，提供某一业务过程事件涉及用什么过滤和分类的描述属性</strong>，&quot;谁、什么时候、什么地点、为什么、如何&quot;干了什么，维度表示维度建模的基础和灵魂</li>
<li>比如，&quot;小王早上在小卖部花费5元钱购买了包子&quot;，时间维度——早上，地点维度——小卖部，商品维度——包子</li>
<li>维度表包含了业务过程记录的业务过程度量的上下文和环境。维度表都包含单一的主键列，<strong>维度表设计的核心是确定维度字段，维度字段是查询约束条件(where)、分组条件(group)、排序(order)，与报表标签的基本来源</strong>。</li>
<li>维度表通常比较宽**，包含多个属性、是扁平的规范表**，实际应用中包含几十个或者上百个属性的维度并不少见，维度表应该包括一些<strong>有意义的描述</strong>，方便下游使用</li>
<li>维度表的维度属性，应该尽可能的丰富，所以维度表中，经常出现一些反范式的设计，把维度属性并到主维度属性中，达到易用少关联的效果。</li>
<li>维度表的设计包括维度选择，主维表的确定，梳理关联维度，定义维度属性的过程</li>
<li>维度的选择一般从报表需求和从业务人员的交谈中发现，主要用于过滤、分组、排序</li>
<li>主维度表一般从业务库直接同步，比如用户表</li>
<li>关联维度主要是不同业务系统或者同一业务系统的表之间存在关联性(范式建模)，根据对业务表的梳理，确定哪些表和主维度表之间存在关联关系，并选择其中的某些表用于生成维度属性。</li>
</ul>
<h5 id="渐变维度维表">渐变维度维表</h5>
<ul>
<li>维度数据会随着时间发生变化，变化速度非常缓慢。eg：电商平台的用户维度表，用户的收货地址是缓慢变化的。</li>
</ul>
<h4 id="标签数据层tdm">标签数据层(TDM)</h4>
<ul>
<li>面向对象建模，对跨业务板块、跨数据域的特定对象进行数据整合，通过统一的ID-Mapping 把各个业务板块，各个业务过程中<strong>同一对象的数据打通</strong>，形成对象的全域数据标签体系，方便深度分析、挖掘、应用。</li>
</ul>
<h5 id="标签的分类">标签的分类</h5>
<ul>
<li>标签按照产生和计算方式的不同可分为属性标签，统计标签，算法标签，关联标签</li>
</ul>
<h6 id="属性标签">属性标签</h6>
<ul>
<li>对象本身的性质就是属性标签</li>
</ul>
<h6 id="统计标签">统计标签</h6>
<ul>
<li>对象在业务过程中产生的原子指标，通过不同的计算方法可以生成统计标签</li>
</ul>
<h6 id="算法标签">算法标签</h6>
<ul>
<li>对象在多个业务过程中的特征规律通过一定的算法产出的标签</li>
</ul>
<h6 id="关联标签">关联标签</h6>
<ul>
<li>对象在特定的业务过程会和其他对象关联，关联对象的标签也可以打在主对象上</li>
</ul>
<h5 id="对象标识">对象标识</h5>
<ul>
<li>对象的标识可以标识一个对象，一般是对象的ID,比如手机号，身份证，登录账号</li>
</ul>
<h5 id="标签">标签</h5>
<ul>
<li>利用原始数据，通过一定的逻辑加工产出直接能被业务所直接使用的、可阅读的，有价值的数据。</li>
</ul>
<h5 id="标签类目">标签类目</h5>
<ul>
<li>是标签的分类组织方式，是标签信息的一种结构化描述，目的是管理、查找，一般采用多级类目</li>
<li>一般当标签的个数超过50个的时候，业务人员查找标签就会变得非常麻烦，</li>
</ul>
<h5 id="id-mapping">ID-Mapping</h5>
<blockquote>
<p>一个自然人他有身份证号码进行唯一标识，但是在医保的时候他使用的实医保账号，缴纳水电费的时候又是不同的账号，使用手机的时候又是设备账号，上网的时候是网商账号。</p>
</blockquote>
<ul>
<li>在确认对象后，由于同一对象在不同的业务体系中的对象标识是不一样的，因此需要将同一对象上的不同ID  标识打通，以便所有的业务数据都能够在该对象上打通。</li>
<li>完成对象的ID 打通需要给对象设置一个超级ID,需要根据对象当前业务体系的ID和获取得到或者计算得到超级ID,进而完成所有业务标识的ID打通</li>
<li>一般来说ID 打通是建设标签体系的前提，如果没有ID打通就无法收集到一个对象的全面信息，也就无法对这个对象进行全面的标签刻画。</li>
</ul>
<h6 id="id-mapping-的计算">ID-Mapping 的计算</h6>
<ul>
<li>传统的计算方法要有 ID-ID 之间的两两关系，例如邮箱和手机号可以打通，手机号和身份证号可以打通，那么邮箱就和身份证号可以打通，但是当数据量非常大，且业务板块非常多的时候，例如有上一个对象，每个对象有数十种ID,这个时候打通就需要非常漫长的计算</li>
</ul>
<h4 id="ads-层">ADS 层</h4>
<ul>
<li>数仓层，DIM 层，TDM 层是相对稳定的，所以无法满足灵活多变业务需求，所以这和数仓层的规范和划分相矛盾，所以我们在此基础上建立了另外一个层，这就是ADS 层，解决了规划稳定和灵活多变之间的矛盾。</li>
<li>数据应用层，按照业务的需要从统一数仓层和DIM进行取数，并面向业务的特殊需求对数据进行加工,以满足业务和性能的需求。</li>
<li>ADS 层因为面向的实众多的需求，所以这一层没有太多的规范，只需要按照命名规范来进行就可以了</li>
</ul>
<h5 id="ads-层设计">ADS 层设计</h5>
<ul>
<li>ADS 层的建设是强业务推动的，业务部门需要参与到ADS 的建设中来</li>
</ul>
<h6 id="实现流程">实现流程</h6>
<ul>
<li>理清需求，了解业务方对数据内容、使用方式(怎么交互的，报表、接口、即席查询、在线查询、指标查询、搜索)、性能的要求</li>
<li>盘点现有的数仓表是否可以支持</li>
<li>代码实现，选择合适的存储引擎和查询引擎</li>
</ul>
<h6 id="使用场景与性能">使用场景与性能</h6>
<ul>
<li>针对业务方的使用场景，我们需要设计出高效，满足要求的ADS 层表</li>
<li>如果是多维分析，为了减少连接，提升性能，我们一般采用大宽表设计，使用高性能引擎支撑</li>
<li>如果是特定指标查询，一般采用KV的形式组织</li>
<li>如果是搜索场景，一般采用搜索引擎</li>
</ul>
<h4 id="dm-层数据集市层">DM 层数据集市层</h4>
<ul>
<li>主要是提供数据产品和数据分析的数据，一般会存放在ES、Mysql、也可能直接存储在hive中或者druid供数据分析和数据挖掘使用。</li>
<li>主要<strong>解决部门用户报表和分析需求</strong>而建立数据库，数据集市就代表数据仓库的主题域</li>
</ul>
<h3 id="模型落地实现">模型落地实现</h3>
<ol>
<li>按照命名规范创建表</li>
<li>开发生成维表和事实表的代码</li>
<li>进行代码逻辑测试，验证数据加工逻辑的正确性</li>
<li>代码发布，加入调度并配置相应的质量监控和报警机制</li>
</ol>
<h2 id="总线矩阵核心概念">(总线矩阵)核心概念</h2>
<h3 id="业务板块"><strong>业务板块</strong></h3>
<ul>
<li>根据业务属性划分出相对独立的业务板块，业务板块是一种<strong>很大的划分</strong>，各个业务板块<strong>重叠度非常低</strong>，<strong>数据独立建设</strong>，比如地产板块、金融板块、医疗板块、电商板块</li>
</ul>
<h3 id="模型设计"><strong>模型设计</strong></h3>
<ul>
<li>以维度建模为理论基础，基于维度建模的总线架构，<strong>构建一致性的维度表和事实表，同时设计出一套命名规范</strong></li>
</ul>
<h3 id="数据域"><strong>数据域</strong></h3>
<ul>
<li>数据域是<strong>数仓层的顶层划分</strong>，是一个<strong>较高层次的数据归类标准</strong>，是<strong>对企业的各个业务过程进行抽象、提炼、组合成的集合，面向业务分析</strong></li>
<li>一个数据域对应一个宏观分析领域，例如采购域、供应链域、学生域、老师域、CR域、CC域、排课域</li>
<li>数据域是抽象提炼出来的，并且不容易变动，既能涵盖当前所有业务需求，又能在新的业务进入时无影响的将其分配到已有的数据域，只有当前数据域分类都不合适的时候才会扩展到新的数据域</li>
<li>数据域的特点是抽象、长期维护和更新、但是不宜变更</li>
</ul>
<blockquote>
<p>为保障整个体系的生命力，数据域是需要抽象提炼并且长期维护更新的，但不轻易变动。在划分数据域时，既要能涵盖所有业务需求，又能在新业务进入时无影响的包含已有的数据还要扩展新的数据域。</p>
</blockquote>
<ul>
<li>数据域的创建需要经过这样几个流程，第一数据调研(业务调研)，第二业务分类，第三数据域定义(数据域的名称)，第四总线矩阵构建</li>
</ul>
<table>
<thead>
<tr>
<th>域名</th>
<th>业务过程</th>
</tr>
</thead>
<tbody>
<tr>
<td>会员域</td>
<td>会员注册、登录、退出、冻结、注销</td>
</tr>
<tr>
<td>商品域</td>
<td>商品发布、上架、下架、属性变更</td>
</tr>
<tr>
<td>日志域</td>
<td>曝光、点击、浏览、收藏、滑动、搜索</td>
</tr>
</tbody>
</table>
<h3 id="业务过程">业务过程</h3>
<ul>
<li>业务过程是企业的业务活动事件，且是企业经营过程中不可拆分的事件，比如下订单、账号注册、银行转账都是业务过程</li>
</ul>
<h3 id="修饰词">修饰词</h3>
<ul>
<li>修饰词指的是出统计指标以外的对指标进行限定抽象的业务场景，修饰词属于一个修饰类型，比如值日志域的访问终端下，有修饰词PC,w无线端、手机端，IOS</li>
<li>修饰词的出现是为了方便管理</li>
</ul>
<h3 id="时间周期">时间周期</h3>
<ul>
<li>用来明确数据统计的时间范围或时间点</li>
</ul>
<h3 id="原子指标">原子指标</h3>
<ul>
<li>原子指标是针对某一业务的<strong>行为的度量</strong>，是一种不可拆分的指标，有明确的业务含义，比如支付金额，注册用户数</li>
<li>原子指标有确定的字段名称，数据类型，算法说明，所属数据域和业务过程，原子指标一般采用<strong>动作_度量</strong>的方式命名，例如注册学生</li>
</ul>
<h3 id="一致性指标扩展指标">一致性指标(扩展指标)</h3>
<ul>
<li>指标归属到具体的数据域，指标的定义、名称、类型、计算方法，确保指标的全局一致性</li>
<li>一致性指标用来描述原子指标、修饰词、时间周期和派生指标的含义、类型、命名、算法，被用于模型设计</li>
<li>一致性指标=原子指标+时间修饰词+其他修饰词，例如 最近7天(时间修饰词)支付(其他修饰词)积分，最近1月注册用户数</li>
</ul>
<h3 id="计算方法">计算方法</h3>
<ul>
<li>指标的数学计算公式，比如汇总、平均、最值</li>
</ul>
<h3 id="事实表-2">事实表</h3>
<ul>
<li>事实表是观察事物得到的事实数据，事实设计来自业务过程事件的描述，例如一次购买行为</li>
<li>事实表是数仓建设的主要产物，数仓绝大部分都是事实表，事实表主要由两部分组成，第一部分主键和外键组成的键值部分，第二部分加事实明细组成，外键通常对应维度表的主键。</li>
</ul>
<h3 id="olap">OLAP</h3>
<h4 id="rolap">ROLAP</h4>
<ul>
<li>基于关系型数据库，不需要预计算</li>
<li>加快速度的方式主要是使用内存和优化算法(presto,impala)</li>
</ul>
<h4 id="moalp">MOALP</h4>
<ul>
<li>基于多维数据集，需要预计算，加快速度的方式是预计算</li>
<li>一个多维数据集叫做 OLAP CUBE</li>
</ul>
<h5 id="钻取">钻取</h5>
<ul>
<li>钻取是改变维的层次，变换分析的粒度。它包括向上钻取（roll up）和向下钻取（drill down）</li>
</ul>
<h6 id="roll-up">roll up</h6>
<ul>
<li>roll up是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数(从小到大)</li>
<li>是指自动生成汇总行的分析方法。通过向导的方式，用户可以定义分析因素的汇总行，例如对于各地区各年度的销售情况，可以生成地区与年度的合计行，也可以生成地区或者年度的合计行</li>
</ul>
<h6 id="drill-down">drill down</h6>
<ul>
<li>rill down则相反，它从汇总数据深入到细节数据进行观察或增加新维(从大到小)</li>
<li>例如，用户分析&quot;各地区、城市的销售情况&quot;时，可以对某一个城市的销售额细分为各个年度的销售额，对某一年度的销售额，可以继续细分为各个季度的销售额。通过钻取的功能，使用户对数据能更深入了解，更容易发现问题，做出正确的决策</li>
</ul>
<h2 id="建模工具">建模工具</h2>
<h3 id="navicate">navicate</h3>
<h4 id="利用已有的表进行">利用已有的表进行</h4>
<figure data-type="image" tabindex="5"><img src="BCE1DE43CA9D4F748FA013E85B4009C3" alt="image" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="762F4CEFD6394422988B30AE66423DAE" alt="image" loading="lazy"></figure>
<h4 id="建立新的模型图">建立新的模型图</h4>
<figure data-type="image" tabindex="7"><img src="C82827BEE31645089015A9C3E65C8098" alt="image" loading="lazy"></figure>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kingcall.github.io/post/xi-tong-she-ji-ru-men/">
                  <h3 class="post-title">
                    系统设计入门
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
