<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kingcall.github.io</id>
    <title>Welcome to Kingcall&apos;s GitHub Pages</title>
    <updated>2020-08-18T14:11:47.056Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kingcall.github.io"/>
    <link rel="self" href="https://kingcall.github.io/atom.xml"/>
    <subtitle>生命不息 奋斗不止</subtitle>
    <logo>https://kingcall.github.io/images/avatar.png</logo>
    <icon>https://kingcall.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Welcome to Kingcall&apos;s GitHub Pages</rights>
    <entry>
        <title type="html"><![CDATA[数据平台]]></title>
        <id>https://kingcall.github.io/post/shu-ju-ping-tai/</id>
        <link href="https://kingcall.github.io/post/shu-ju-ping-tai/">
        </link>
        <updated>2020-08-18T14:10:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="数据平台建设">数据平台建设</h2>
<h3 id="平台要解决的问题">平台要解决的问题</h3>
<ul>
<li>数据质量层次不齐</li>
<li>数据交换和共享困难</li>
<li>缺乏有效的管理机制</li>
<li>存在数据安全隐患</li>
</ul>
<h3 id="平台架构要求的能力">平台架构要求的能力</h3>
<ul>
<li>无数据模型的架构</li>
</ul>
<blockquote>
<p>很多时候数据处理都是在一个无模式或者非结构化或者半结构化的数据集上进行处理</p>
</blockquote>
<ul>
<li>近实时的数据采集</li>
</ul>
<blockquote>
<p>批量采集和实时采集</p>
</blockquote>
<ul>
<li>微批处理的能力</li>
<li></li>
</ul>
<h3 id="基础设施的要求">基础设施的要求</h3>
<ul>
<li>线性可扩展</li>
<li>高吞吐量</li>
<li>容错能力</li>
<li>分布式数据处理</li>
</ul>
<h2 id="具体的平台化工具">具体的平台化工具</h2>
<h3 id="任务调度系统">任务调度系统</h3>
<ul>
<li>数据采集任务、数据同步任务、数据清洗任务、数据分析任务等；这些任务除了定时调度，还存在非常复杂的任务依赖关系，比如：数据分析任务必须等相应的数据采集任务完成后才能开始；数据同步任务需要等数据分析任务完成后才能开始；</li>
<li>调度系统，更确切地说，作业调度系统（Job Scheduler）或者说工作流调度系统（workflow Scheduler）是任何一个稍微有点规模，不是简单玩玩的大数据开发平台都必不可少的重要组成部分。</li>
</ul>
<blockquote>
<p>除了Crontab，Quartz这类偏单机的定时调度程序／库。开源的分布式作业调度系统也有很多，比较知名的比如：oozie，azkaban，chronos，zeus等等，此外，还有包括阿里的TBSchedule，SchedulerX，腾讯的Lhotse，当当的elastic-job，唯品会的Saturn等等</p>
</blockquote>
<blockquote>
<p>可以说，几乎每家稍微有点规模的数据平台团队，都会有自己的调度系统实现方案，要不然自研，要不然在开源的基础上进行一些封装和改造（比如很多公司采取了封装oozie的方式）。</p>
</blockquote>
<blockquote>
<p>资源调度系统，它的工作重点是底层物理资源的分配管理，目标是最大化的利用集群机器的CPU／磁盘／网络等硬件资源，所调配和处理的往往是与业务逻辑没有直接关联的通用的程序进程这样的对象。</p>
</blockquote>
<blockquote>
<p>作业调度系统有时也会考虑负载均衡问题，但保证负载均衡更多的是为了系统自身的健壮性，而资源的合理利用，作为一个可以优化的点，往往依托底层的资源调度系统来实现。</p>
</blockquote>
<blockquote>
<p>一个成熟易用，便于管理和维护的作业调度系统，需要和大量的周边组件对接，不仅包括各种存储计算框架，还可要处理或使用到包括：血缘管理，权限控制，负载流控，监控报警，质量分析等各种服务或事务。这些事务环节，在每家公司往往都有自己的解决方案，所以作业调度系统所处的整体外部环境，千差万别，再加上各公司各种业务流程的定制化需求进一步加大了环境的差异性，所以，调度系统很难做到既能灵活通用的适配广大用户的各种需求，又不落到太过晦涩难用的地步。</p>
</blockquote>
<h4 id="调度类型">调度类型</h4>
<h5 id="依赖调度">依赖调度</h5>
<ul>
<li>父依赖执行完开始执行</li>
</ul>
<h5 id="时间调度">时间调度</h5>
<ul>
<li>到达特定的时间点开始执行</li>
</ul>
<h4 id="依赖推荐">依赖推荐</h4>
<ul>
<li>随着数仓的建设，表越来越多，依赖推荐尤为重要，自动依赖推荐可以避免少添加依赖的数据错误(数据错误任务状态不会错误，不容易发现，只能通过数据质量监控平台或者业务方反馈)、多添加依赖的无用等待，以及循环依赖的致命错误</li>
</ul>
<h4 id="基线控制">基线控制</h4>
<blockquote>
<p>大数据离线计算通常作业执行时间比较长，如果不能及时发现问题，重跑需要几个小时，显然来不及</p>
</blockquote>
<h5 id="统一管理">统一管理</h5>
<ul>
<li>统一管理作业的完成时间、优先级、告警策略、保证数据加工按时完成，调度模块需要根据重要性、优先级、最短执行时间策略进行动态资源调整，让资源利用率最大化，损失最小化</li>
</ul>
<h5 id="算法预测和调控">算法预测和调控</h5>
<ul>
<li>算法对正常数据进行训练，当作业无法正正常产出和动态调整资源无法完成的时候，调度中心会通知运维和值班人员进行接入处理。</li>
</ul>
<h4 id="代码校验">代码校验</h4>
<ul>
<li>设计了代码上线时候的语法检测，并且设计了试运行和线上以及测试三种运行模式，上线的时候必须有试运行成功的记录</li>
</ul>
<h4 id="环境隔离">环境隔离</h4>
<ul>
<li>通过运行模式实现了测试和试运行以及线上形成了测试环境、uat环境、线上三种环境</li>
</ul>
<h4 id="多引擎支持">多引擎支持</h4>
<ul>
<li>支持自定义脚本，hive,sprk,python，等多种引擎</li>
</ul>
<h4 id="功能">功能</h4>
<ul>
<li>用户可以在管控后台中，自主的对拥有权限的作业／任务进行管理，包括添加，删除，修改，重跑等。对没有权限的作业，只能检索信息。</li>
<li>支持当日任务计划和执行流水的检索，支持周期作业信息的检索，包括作业概况，历史运行流水，<strong>运行日志，变更记录，依赖关系树查询等</strong>。</li>
<li>支持作业失败自动重试，可以设置<strong>自动重试次数，重试间隔</strong>等</li>
<li>支持<strong>历史任务独立重刷或按照依赖关系重刷后续整条作业链路</strong></li>
<li>允许<strong>设置作业生命周期，可以临时禁止或启用一个周期作业</strong></li>
<li>支持任务<strong>失败报警，超时报警，到达指定时间未执行报警等异常情况的报警监控</strong></li>
<li>支持动态按应用／业务／<strong>优先级等维度调整作业执行的并发度<br>
调度时间和数据时间的分离</strong></li>
</ul>
<blockquote>
<p>支持灰度功能，允许按特定条件筛选作业按照特定的策略灰度执;根据血缘信息，自动建立作业依赖关系;任务日志分析，自动识别错误原因和类型</p>
</blockquote>
<h3 id="元数据管理系统元数据治理">元数据管理系统(元数据治理)</h3>
<h4 id="权限管理">权限管理</h4>
<ul>
<li>数据安全
<ul>
<li>数据脱敏</li>
<li>核心数据的权限管理</li>
</ul>
</li>
</ul>
<h4 id="血缘关系">血缘关系</h4>
<h4 id="数据生命周期管理">数据生命周期管理</h4>
<h4 id="数仓的治理规范的落地">数仓的治理规范的落地</h4>
<ul>
<li>建表的权限</li>
<li>命名是否规则</li>
</ul>
<h3 id="数据质量监控平台">数据质量监控平台</h3>
<blockquote>
<p>随着大数据时代的带来，数据的应用也日趋繁茂，越来越多的应用和服务都基于数据而建立，数据的重要性不言而喻。而且，数据质量是数据分析和数据挖掘结论有效性和准确性的基础，也是这一切的数据驱动决策的前提！如何保障数据质量，确保数据可用性是每一位数据人都不可忽略的重要环节。</p>
</blockquote>
<ul>
<li>完整性、准确性、一致性和及时性<br>
<img src="840FF9F582A8454BB07FB02700261E79" alt="image" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="1"><img src="WEBRESOURCE82b4c0fa329fc626c8df0629b201718e" alt="image.png" loading="lazy"></figure>
<h4 id="完整性">完整性</h4>
<ul>
<li>完整性是指数据的记录和信息是否完整，是否存在缺失的情况。数据的缺失主要包括记录的缺失和记录中某个字段信息的缺失，两者都会造成统计结果不准确，所以说<strong>完整性是数据质量最基础的保障</strong></li>
<li>考虑两个方面：一是，数据条数是否少了，二是，某些字段的取值是否缺失。完整性的监控，多出现在日志级别的监控上，一般会在数据接入的时候来做数据完整性校验。</li>
</ul>
<h5 id="数据同步工具故障">数据同步工具故障</h5>
<h5 id="数据被归档">数据被归档</h5>
<h4 id="准确性">准确性</h4>
<ul>
<li>准确性是指<strong>数据中记录的信息和数据是否准确，是否存在异常或者错误的信息</strong>。</li>
<li>直观来讲就是看数据是否上准确的。一般准确性的监控多集中在对业务结果数据的监控，比如<strong>每日的活跃、收入等数据是否正常</strong></li>
<li>常见的度量规则，空值检测、重复值检测、相关性检测、波动性检测、阈值检测、业务逻辑规则检测(非常重要)</li>
</ul>
<h4 id="一致性">一致性</h4>
<ul>
<li>一致性是指同一指标在不同地方的结果是否一致</li>
<li>数据不一致的情况，多出现在数据系统达到一定的复杂度后，同一指标会在多处进行计算，由于计算口径或者开发人员的不同，容易造成同一指标出现的不同的结果。</li>
</ul>
<h4 id="及时性">及时性</h4>
<ul>
<li>在确保数据的完整性、准确性和一致性后，接下来就要保障数据能够及时产出，这样才能体现数据的价值</li>
<li>及时性很容易理解，主要就是数据计算出来的速度是否够快，这点在数据质量监控中可以体现在监控结果数据数据是否在指定时间点前计算完成。</li>
<li>主要随着数据规模的变化，导致边界问题对数据的及时性的影响越来越大(集群故障、网络故障、流量激增)</li>
</ul>
<blockquote>
<p>其实主要是数据源的监控、数据指标的监控、数据表的监控、高级一点的会涉及到全链路的监控</p>
</blockquote>
<h4 id="监控平台设计思路">监控平台设计思路</h4>
<pre><code>数据：主要是需要被数据质量监控到的数据，数据可能存放在不同的存储引擎中，比如Hive、PG、ES等。

规则：是指如何设计发现异常的规则，一般而言主要是数值的异常和环比等异常监控方式。也会有一些通过算法来发掘异常数据的方法。

告警：告警是指出发告警的动作，这里可以通过微信消息、电话、短信或者是微信小程序的方式来触发告警内容。

反馈：这里需要特别注意，反馈是指对告警内容的反馈，比如说收到的告警的内容，那么负责人要来回应这个告警消息是否是真的异常，是否需要忽略该异常，是否已经处理了该异常。有了反馈的机制，整个数据质量监控才容易形成闭环。更能体现业务价值。
</code></pre>
<figure data-type="image" tabindex="2"><img src="82022BF0420545ACA7DCB277E04DE314" alt="image" loading="lazy"></figure>
<ul>
<li>问题:告警信息太多了,容易被忽略,主要是思路是提高告警的准确率，避免无用的告警</li>
</ul>
<blockquote>
<p>多使用机器学习算法的方式来发现异常点，比如：异常森林。</p>
</blockquote>
<blockquote>
<p>加入反馈机制，如果业务负责人认为该告警是正常的，就打上正常的tag，后续告警规则根据反馈进行优化。</p>
</blockquote>
<blockquote>
<p>加入屏蔽功能，屏蔽不感兴趣的告警。</p>
</blockquote>
<h3 id="数据同步平台">数据同步平台</h3>
<ul>
<li>主要有增量同步、全量同步、基于binlog 的实时同步，不论哪种方式到最后都涉及到数据更新合并的问题</li>
<li>由于数据湖的发展，可能会改变基于binlog 的同步方式(离线——(kafka/hbase),实时——hbase)</li>
<li>这个平台也很重要，因为这是一切的数据来源，而且随着业务的发展，要对接各种各样的数据源，数据同步平台的稳定与准确是一切的基础保障</li>
</ul>
<h4 id="数据同步方式工具">数据同步方式(工具)</h4>
<h5 id="数据库直连同步">数据库直连同步</h5>
<p>-sqoop</p>
<h6 id="数据库文件同步">数据库文件同步</h6>
<ul>
<li>自定义脚本</li>
</ul>
<blockquote>
<p>会遇到两个问题，一个是网络波动可能会丢包，另一个是源文件比较大需要进行压缩传输。因而通常在传输数据文件的同时，会上传一个校验文件，检测数据量、文件大小等信息，以保证数据同步的准确性</p>
</blockquote>
<h5 id="数据库日志解析同步">数据库日志解析同步</h5>
<ul>
<li>maxwell、cancel</li>
</ul>
<blockquote>
<p>大多数主流数据库都可以通过日志文件的方式进行系统的恢复，并且由于日志文件的信息记录非常完整，格式解析也很稳定，因而完全可以通过解析数据库日志文件来获得发生变更的数据，再更新离线系统以最大提升效率</p>
</blockquote>
<h4 id="数据更新">数据更新</h4>
<ul>
<li>数据库日志解析实现了<strong>准实时同步的能力，对业务系统的影响也很小</strong>，因而广泛的应用在了从业务系统到数据仓库的增量数据同步应用之中。值得注意的是，由于数据仓库对于更新操作支持比较差，通常会采用先删除、再插入的方式来模拟更新操作</li>
<li>主要实现方式有两种，一种是通过join 的方式，另外一种是row_number()的方式</li>
</ul>
<blockquote>
<p>数据延迟、处理数据量较大及数据漂移，因而中间系统的建设也需要进行一定的编码开发，以消除数据不一致的情况</p>
</blockquote>
<h3 id="数据资产服务平台">数据资产服务平台</h3>
<ul>
<li>数据资产的定义是由企业拥有或者控制的，能够为企业未来带来经济利益的，以物理或者电子方式记录的数据资源，如文件资料或者数字资料</li>
<li>对外提供数据支持，直接服务于各个业务线已经公司的数据分析师，只有业务能够读懂能够理解的数据才叫数据资产</li>
</ul>
<h4 id="数据分析平台adhoc">数据分析平台(adhoc)</h4>
<ul>
<li>相对于adhoc 而言提供了可视化的功能</li>
<li>zeeplin</li>
<li>superset</li>
<li>adhoc(自研)</li>
</ul>
<h4 id="接口服务数据资产服务平台">接口服务(数据资产服务平台)</h4>
<ul>
<li>提供sql 的方式进行接口配置，对接口进行统一管理，安全、性能、稳定性、生命周期、监控</li>
<li>充当数据的提供方，报表数据、计算指标、明细数据、用户画像数据</li>
</ul>
<h4 id="报表服务数据资产服务平台">报表服务(数据资产服务平台)</h4>
<ul>
<li>BI 工具，支持报表和 Dashboard</li>
<li>需要接口服务的接口(其实也可以直接采用sql 配置的方式)</li>
</ul>
<h3 id="实时数仓">实时数仓</h3>
<ul>
<li>资源层面——所有调度任务只能在业务闲时（凌晨）集中启动，集群压力大，耗时越来越长；</li>
<li>业务层面——数据按T+1更新，延迟高，数据时效价值打折扣，无法精细化运营与及时感知异常。</li>
</ul>
<blockquote>
<p>实时数仓即离线数仓的时效性改进方案，从原本的小时/天级别做到秒/分钟级别。</p>
</blockquote>
<blockquote>
<p>底层设计变动的同时，需要尽力保证平滑迁移，不影响用户（分析人员）之前的使用习惯</p>
</blockquote>
<h4 id="指导思想kappa架构">指导思想：Kappa架构</h4>
<h4 id="计算引擎">计算引擎</h4>
<ul>
<li>批流一体化——能同时进行实时和离线的操作</li>
<li>提供统一易用的SQL interface——方便开发人员和分析人员</li>
</ul>
<h4 id="底层事实数据存储引擎">底层（事实数据）存储引擎</h4>
<blockquote>
<p>可靠存储——有一定持久化能力，高可用，支持数据重放。</p>
</blockquote>
<ul>
<li>kafka</li>
</ul>
<h4 id="实时平台">实时平台</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据仓库]]></title>
        <id>https://kingcall.github.io/post/shu-ju-cang-ku/</id>
        <link href="https://kingcall.github.io/post/shu-ju-cang-ku/">
        </link>
        <updated>2020-08-18T14:08:35.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<ul>
<li>数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。</li>
<li>企业需要对不同来源、不同形式、不同主题的数据整合起来，供给数据分析、数据挖掘、数据报表使用时，有这么一个中间层将各种原始数据科学地加工处理成下游需要的样子。<strong>这个中间层就是数据仓库产生价值的地方</strong></li>
</ul>
<h2 id="建模流程">建模流程</h2>
<h3 id="业务建模">业务建模</h3>
<ul>
<li>根据业务部门进行划分，理清部门之间的关系，然后将<strong>各个部门的具体业务程序化</strong>，与业务部门开会<strong>协商出需求的指标、保存年限、维度</strong>等等。</li>
<li>总体来讲，就是要<strong>知道他们需要哪些指标以及他们能提供哪些数据</strong>。</li>
<li>业务建模的时间最长，而且与公司实际的业务环境息息相关，因此在这里需要根据实际生产环境和业务需求确认好数据仓库使用的工具和平台。</li>
</ul>
<h3 id="概念建模">概念建模</h3>
<ul>
<li><strong>将业务模型抽象化，分组合并类似的概念，细化概念</strong>，抽象出实体与实体之间的联系，理清各组概念之间的联系。</li>
<li>说白了就是画图，把指标需要的哪些数据封装到一个实体里，实体与实体之间的关联等等用ER图表示出来。</li>
<li>先画出局部ER图，最后再综合画出全局ER图。</li>
</ul>
<h3 id="逻辑建模">逻辑建模</h3>
<ul>
<li>将概念模型实体化，具体考虑概念对应的属性，事件考虑事实属性，维度考虑维度属性。</li>
<li>总体来说就是建表，前面已经画出了关系图，这里只要将表里头有哪些字段考虑出来就可以，如果是事实表就考虑事实字段和业务主键，如果是维度表就考虑维度属性，SCD策略等等。在这里需要确定数据粒度，如果多个指标都用到一个字段，则取粒度最小的指标。如果不确定指标的量度，则取毫秒级作为粒度。</li>
</ul>
<h3 id="物理建模">物理建模</h3>
<ul>
<li>综合现实的大数据平台、采集工具、etl工具、数仓组件、性能要求、管理要求等多方面因素，设计出具体的项目代码，完成数仓的搭建。</li>
</ul>
<h2 id="建模方法论">建模方法论</h2>
<ol>
<li><strong>访问性能</strong>：能够快速查询所需的数据，减少数据I/O。<br>
1.** 数据成本**：减少不必要的数据冗余，实现计算结果数据复用，降低大数据系统中的存储成本和计算成本。</li>
<li><strong>使用效率</strong>：改善用户应用体验，提高使用数据的效率。</li>
<li><strong>数据质量</strong>：改善数据统计口径的不一致性，减少数据计算错误的可能性，提供高质量的、一致的数据访问平台。</li>
</ol>
<blockquote>
<p>需要注意的建模其实是和公司的业务、公司的数据量、公司使用的工具、公司数据的使用方式密不可分的</p>
</blockquote>
<h3 id="范式建模关系型数据库">范式建模(关系型数据库)</h3>
<ul>
<li>范式建模法其实是我们在构建数据模型常用的一个方法，该方法的主要由Inmon所提倡，主要解决关系型数据库得数据存储，利用的一种技术层面上的方法，主要用于业务系统，<strong>所以范式建模主要是利用关系型数据库进行数仓建设</strong></li>
<li>目前，我们在关系型数据库中的建模方法，大部分采用的是三范式建模法。</li>
<li>符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>
</ul>
<h4 id="三范式">三范式</h4>
<h5 id="第一范式">第一范式</h5>
<ul>
<li>属性值不可再分</li>
</ul>
<h5 id="第二范式">第二范式</h5>
<ul>
<li>要求每张表都要有一个主键，其它记录完全依赖主键。要求实体的属性<strong>完全依赖于主关键字</strong>。</li>
</ul>
<blockquote>
<p>例如，如果花名册里只有名字，没有学号，则重名的话会很麻烦。</p>
</blockquote>
<ul>
<li>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。</li>
</ul>
<h5 id="第三范式">第三范式</h5>
<ul>
<li>所有字段只能依赖主键，不得依赖于其它字段(非主属性)。消除依赖传递。</li>
</ul>
<h4 id="范式建模的优缺点">范式建模的优缺点</h4>
<h5 id="优点">优点</h5>
<ul>
<li>节约存储(尤其是利用数据库进行数仓建设的时候)</li>
<li>结构清晰，易于理解</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>构建比较复杂</li>
<li>查询复杂(需要很多的关联)</li>
<li>不适合在大数据环境下构建(1 查询复杂  2 存储很便宜)</li>
</ul>
<h4 id="为什么还要学习范式建模">为什么还要学习范式建模</h4>
<ul>
<li>上游数据源往往是业务数据库，而这些业务数据库采用的实范式建模，所以了解范式建模可以帮助我们去合理的建设数仓</li>
</ul>
<blockquote>
<p>如果了解范式建模，从er 模型可以了解到数据架构，例如一个电商系统，从er模型就可以知道哪些涉及到商品的管理、用户的管理、订单管理，拿到这些关系之后，我们就可以更好的进行数仓管理与建设</p>
</blockquote>
<ul>
<li>数据源的规范定义需要我们了解范式理论，可以更好的和业务系统进行对接</li>
<li>数仓的稀有系统，如报表系统设计的时候也会使用到范式建模</li>
</ul>
<h3 id="er实体建模">ER实体建模</h3>
<ul>
<li>将事务抽象为&quot;实体&quot;（Entity）、&quot;属性&quot;（Property）、&quot;关系&quot;（Relationship）来<strong>表示数据关联和事物描述</strong>，这种<strong>对数据的抽象建模</strong>通常被称为ER实体关系模型。</li>
<li>实体建模法并不是数据仓库建模中常见的一个方法，它来源于哲学的一个流派。</li>
<li>从哲学的意义上说，客观世界应该是可以细分的，客观世界应该可以分成由一个个实 体，以及实体与实体之间的关系组成。我们在数据仓库的建模过程中完全可以引入这个抽象的方法，<strong>将整个业务也可以划分成一个个的实体，而每个实体之间的 关系，以及针对这些关系的说明就是我们数据建模需要做的工作</strong>。</li>
<li></li>
</ul>
<blockquote>
<p>在日常建模中，&quot;实体&quot;用矩形表示，&quot;关系&quot;用菱形，&quot;属性&quot;用椭圆形。ER实体关系模型也称为E-R关系图</p>
</blockquote>
<blockquote>
<p>虽然实体法粗看起来好像有一些抽象，其实理解起来很容易。即我们可以将任何一个业务过程划分成 3 个部分，实体，事件和说明。<br>
描述一个简单的事实：“小明开车去学校上学”。以这个业务事实为例，我们可以把“小明”，“学校”看成是一个实体， “上学”描述的是一个业务过程，我们在这里可以抽象为一个具体“事件”，而“开车去”则可以看成是事件“上学”的一个说明。</p>
</blockquote>
<h4 id="应用场景">应用场景</h4>
<ul>
<li><strong>ER模型是数据库设计的理论基础，当前几乎所有的OLTP系统设计都采用ER模型建模的方式</strong>。</li>
<li>Bill Inom提出的数仓理论，推荐采用ER关系模型进行建模。</li>
<li>BI架构提出分层架构，数仓底层ods、dwd也多采用ER关系模型进行设计。</li>
</ul>
<blockquote>
<p>由于实体建模法，能够很轻松的实现业务模型的划分，因此，在业务建模阶段和领域概念建模阶段，实体建模法有着广泛的应用。</p>
</blockquote>
<h4 id="业务归纳">业务归纳</h4>
<blockquote>
<p>使用的抽象归纳方法其实很简单，任何业务可以看成 3 个部分：</p>
</blockquote>
<ol>
<li>实体，主要指领域模型中特定的概念主体，指发生业务关系的对象</li>
<li>事件，主要指概念主体之间完成一次业务流程的过程，特指特定的业务过程</li>
<li>说明，主要是针对实体和事件的特殊说明</li>
</ol>
<h3 id="维度建模">维度建模</h3>
<blockquote>
<p>维度建模源自数据集市，主要面向分析场景。RalphKimball推崇数据集市的集合为数据仓库，同时也提出了对数据集市的维度建模，将数据仓库中的表划分为事实表、维度表两种类型。</p>
</blockquote>
<ul>
<li>般也称之为星型结构建模，有时也加入一些雪花模型在里面。维度建模是一种面向用户需求的、容易理解的、访问效率高的建模方法</li>
<li>以事实表和维度表组成的星型数据模型</li>
</ul>
<h4 id="事实表">事实表</h4>
<ul>
<li>在ER模型中抽象出了有<strong>实体、关系、属性</strong>三种类别，<strong>在现实世界中，每一个操作型事件，基本都是发生在实体之间的</strong>，伴随着这种操作事件的发生，会产生<strong>可度量的值</strong>，而<strong>这个过程就产生了一个事实表，存储了每一个可度量的事件</strong></li>
<li>可以认为是<strong>主题的各个度量</strong><br>
&quot;昨天早上张三在京东花费200元买了一个皮包&quot;,这里以购买为主题(过程)的话，200就是针对该过程(主题)的一个度量，所以可以看出事实表示包含了维度表的主键，这个时候就需要通过join 进行关联，<strong>在关联的过程中引入了雪花模型和星型模型以及星座模型</strong></li>
<li><strong>事实表的特点就是增长迅速，且主要以数值进行记录</strong></li>
</ul>
<h5 id="事实表的度量">事实表的度量</h5>
<ul>
<li>可加</li>
</ul>
<blockquote>
<p>可以进行任意维度下的累加</p>
</blockquote>
<ul>
<li>半可加</li>
</ul>
<blockquote>
<p>每个学生的各个科目的成绩是可加的，但是全班的各个科目进行累加是没有意义的</p>
</blockquote>
<ul>
<li>不可加</li>
<li>需要注意不可加的在任何情况下都是不可加的，比例或者比率是只针对该行有意义，直接累加无意义</li>
</ul>
<h5 id="一致性">一致性</h5>
<h6 id="内部一致性">内部一致性</h6>
<ul>
<li>在同一个表中，所有记录的粒度和维度是一致的，每一列的单位、枚举值都是一样的</li>
</ul>
<blockquote>
<p>想想掌门的学生课程表，少儿和一对一属于两个业务线，放在一起之后字段都无法统一</p>
</blockquote>
<blockquote>
<p>例如 订单表中的金额的单位要进行统一，不能有的是分，有的是元</p>
</blockquote>
<h6 id="表与表之间的一致性">表与表之间的一致性</h6>
<ul>
<li>在进行多表合并的时候要保证彼此之间是针对同一事实的计算，是在同一粒度和维度之下的</li>
</ul>
<blockquote>
<p>订单表和退单表进行对冲，我们需要保证维度是一致的，例如可以设置订单表的金额是正的，退单表的金额是负的，然后合并分组求和即可。</p>
</blockquote>
<h5 id="事实表设计原则">事实表设计原则</h5>
<ol>
<li>尽可能包括所有业务过程相关的事实</li>
<li>只选择与业务过程相关的事实</li>
<li>分解不可加事实为可加的组件</li>
<li>选择维度和事实之前必须先声明粒度</li>
<li>在同一个事实表中不可以有多重不同粒度的事实</li>
<li>事实的单位要保持一致</li>
<li>对事实的null值要处理</li>
<li>使用退化维提高事实表的易用性</li>
</ol>
<h4 id="维度表">维度表</h4>
<ul>
<li>维度，顾名思义，<strong>看待事物的角度，可以认为是主题的各个属性</strong>，可以认为是对分析主题所属类型的描述。</li>
</ul>
<blockquote>
<p>&quot;昨天早上张三在京东花费200元买了一个皮包&quot;,这里分析时间维度、地点维度(京东)、商品维度(皮包)</p>
</blockquote>
<ul>
<li>维度表一般为<strong>单一主键</strong>，在ER模型中，实体为客观存在的事务，会带有自己的描述性属性，属性一般为文本性、描述性的，这些描述被称为维度。</li>
<li>维度建模的核心是<strong>数据可以抽象为事实和维度</strong>，维度即观察事物的角度，事实某一粒度下的度量词</li>
</ul>
<h5 id="维度表设计">维度表设计</h5>
<ul>
<li>维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成维度属性的优劣，决定了维度是用的方便性，成为数据仓库易用性的关键。</li>
<li><strong>数据仓库的能力直接与维度属性的质量和深度成正比</strong>。</li>
</ul>
<h5 id="维度表基本设计方法">维度表基本设计方法</h5>
<ul>
<li>第一步：选择维度(在已有的维度上进行添加)或者新建维度。作为维度建模的核心，<strong>在企业级数据仓库中，必须保证维度的唯一性。以商品维度为例，有且只有一个维度定义</strong>。</li>
<li>第二步：确定主维表。此处的主维表一般是ODS表，直接与业务系统同步。</li>
<li>第三步：确定相关维表。数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性，根据业务系统的梳理，确定哪些表和主维表存在关联关系，并选择其中的某些表用于生成维度属性。以商品维度为例，根据业务逻辑的梳理，可以得到商品与类目、sku、买家、卖家、店铺等维度存在的关联关系- 第四步：确定维度属性。本步骤主要包括两个阶段，其中一个阶段是从主维表中选择维度属性或生成新的维度属性；第二个阶段是从相关维表中选择维度属性或者生成新的维度属性。以商品维度为例，从主维表和类目、sku、卖家、店铺等相关维表中选择维度属性或者生成新的维度属性</li>
</ul>
<h5 id="缓慢变化维度表">缓慢变化维度表</h5>
<h6 id="重写维度值">重写维度值</h6>
<ul>
<li>采用此种方式，不保留历史数据（简单来说就是更新相关的维度字段）</li>
</ul>
<h5 id="建议">建议</h5>
<ul>
<li>尽可能生成丰富的维度属性；</li>
<li>尽可能多的给出包括一些富有意义的文字描述；</li>
<li>区分数值型属性和事实；</li>
<li>尽可能沉淀出通用的维度属性。</li>
</ul>
<h4 id="模型实现">模型实现</h4>
<ul>
<li>模型主要是源于维度建模过程中，需要对维度表和事实表进行关联的设计。</li>
<li>星型模型和雪花模型的<strong>主要区别在于对维度表的拆分</strong>，<strong>对于雪花模型，维度表的设计更加规范，一般符合3NF</strong>；而<strong>星型模型，一般采用降维的操作，利用冗余来避免模型过于复杂，提高易用性和分析效率</strong>。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="97754E015F1E4D56981C6458BE1B698A" alt="image" loading="lazy"></figure>
<h5 id="雪花模型">雪花模型</h5>
<ul>
<li>星形模式中的维表相对雪花模式来说要大，而且不满足规范化设计。</li>
<li>雪花模型相当于将星形模式的大维表拆分成小维表，满足了规范化设计。然而这种模式在实际应用中很少见，因为这样做会导致开发难度增大，而数据冗余问题在数据仓库里并不严重</li>
<li>可以认为雪花模型是星型模型的一个扩展，每个维度表可以继续向外扩展，连接多个子维度。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="E5EE03DD106F49F2ACE0EB5E751C2D37" alt="image" loading="lazy"></figure>
<h5 id="星型模型">星型模型</h5>
<blockquote>
<p>核心是<strong>一个事实表及多个非正规化描述的维度表</strong>组成，维度表之间是没有关联的，维度表是直接关联到事实表上的</p>
</blockquote>
<ul>
<li>只有当维度表极大，存储空间是个问题时，才考虑雪花型维度，简而言之，最好就用星型维度即可</li>
</ul>
<figure data-type="image" tabindex="3"><img src="246E01B16D424438A25DCCD45D886737" alt="image" loading="lazy"></figure>
<h5 id="星座模型">星座模型</h5>
<figure data-type="image" tabindex="4"><img src="D7C4975ECC40406B8604F687F7404CD2" alt="image" loading="lazy"></figure>
<ul>
<li>前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在业务发展后期，绝大部分维度建模都采用的是星座模式。</li>
<li>可以认为是多个事实表的关联或者是星型模型的关联，其实到了业务发展后期都是星座模型</li>
</ul>
<h4 id="应用场景-2">应用场景</h4>
<ul>
<li>维度建模<strong>是面向分析场景而生</strong>，针对分析场景构建数仓模型，重点关注快速、灵活的解决分析需求，同时能够提供大规模数据的快速响应性能。</li>
<li>针对性强，主要应用于数据仓库构建和OLAP引擎底层数据模型</li>
</ul>
<h4 id="建模的过程">建模的过程</h4>
<ul>
<li>假设我们现在在构建一张订单表</li>
</ul>
<blockquote>
<p>从多个维度进行统计组合，形成多维度数据集，来从多个角度观察业务过程的好坏</p>
</blockquote>
<h5 id="选择业务过程">选择业务过程</h5>
<ul>
<li>业务过程就是需要那<strong>种业务场景下</strong>产生的订单表(划分到那个业务线和数据域)</li>
<li>业务过程就是用户下单的订单记录表</li>
</ul>
<h5 id="申明粒度">申明粒度</h5>
<ul>
<li>粒度就是确认一条记录代表的含义或者是细化到何种程度(一条记录代表一个订单还是多个订单，如拼团的时候团长的单)</li>
<li>一条记录代表一个有效的订单</li>
</ul>
<h5 id="确认维度">确认维度</h5>
<ul>
<li>维度指的是该订单有哪些附属信息，比如订单的类型、支付方式、城市信息、日期信息</li>
<li>商品的维度、用户的维度、支付维度、收货维度、城市维度、日期维度</li>
</ul>
<h5 id="确认事实">确认事实</h5>
<ul>
<li>实时指的是订单的度量数值</li>
<li>订单的金额</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<h5 id="优点-2">优点</h5>
<ul>
<li>方便使用</li>
<li>适合大数据下的处理操作(其实就是shuffle)</li>
<li>适合OLAP操作(上钻下钻)</li>
</ul>
<h5 id="缺点-2">缺点</h5>
<ul>
<li>维度补全后造成的数据浪费</li>
<li>维度变化造成的数据更新量大(例如刷数据的时候，需要刷大量的表)</li>
<li>与典型的范式理论差异很大</li>
</ul>
<blockquote>
<p>既然如此为什么还要使用范式建模呢，其实和我们使用的工具有关系</p>
</blockquote>
<h3 id="分层建设理论">分层建设理论</h3>
<h4 id="分层的意义">分层的意义</h4>
<h5 id="清晰数据结构">清晰数据结构</h5>
<ul>
<li>每一个数据分层都有它的作用域，这样在使用表的时候能更方便的定位和理解。</li>
</ul>
<h5 id="数据血缘追踪">数据血缘追踪</h5>
<ul>
<li>由于最终给业务呈现的是一个能直接使用的业务表，但是表的数据来源有很多，如果有一张来源表出问题了，我们希望能够<strong>快速准确的定位到问题，并清楚他的危害范围和影响范围</strong>。</li>
</ul>
<h5 id="减少重复开发和资源浪费">减少重复开发和资源浪费</h5>
<ul>
<li>规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算</li>
<li>清晰明了的结构使得开发、维护的成本降低</li>
<li>减少重复计算和存储的资源浪费</li>
</ul>
<h5 id="复杂问题简单化">复杂问题简单化</h5>
<ul>
<li>将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。</li>
</ul>
<blockquote>
<p>在实际的建设过程中，由于业务使用数据非常紧急以及统一数仓层建设跟不上业务的需要，所以DIM和ADS层可能直接使用ODS层进行快速的业务响应，但是这种不规范的操作可能导致数据口径不一致，<strong>所以待数仓建设完毕，要切换到统一数仓层和DIM层</strong></p>
</blockquote>
<h4 id="ods">ods</h4>
<ul>
<li>ODS 全称是 OperationalDataStore，操作数据存储&quot;面向主题的&quot;，数据运营层，也叫ODS层，是最接近数据源中数据的一层，数据源中的数据，经过抽取、洗净、传输，也就说传说中的 ETL 之后，装入本层。</li>
<li>本层的数据，总体上大多是<strong>按照源头业务系统的分类方式而分类的</strong>。</li>
</ul>
<blockquote>
<p>但是，这一层面的数据却不等同于原始数据。在源数据装入这一层时，要进行诸如<strong>去噪</strong>(例如有一条数据中人的年龄是300岁，这种属于异常数据，就需要提前做一些处理)、去重(例如在个人资料表中，同一ID却有两条重复数据，在接入的时候需要做一步去重)、字段命名规范等一系列操作</p>
</blockquote>
<ul>
<li>这里的数据处理，并不涉及业务逻辑，仅仅是针对数据完整性以及重复值和空值的处理。</li>
</ul>
<h5 id="设计规范">设计规范</h5>
<ul>
<li>表名的设计 ODS_业务系统_表名，这样的设计可以保持与业务表名一致，又可以有清晰的层次，还可以区分来源。</li>
<li>ods 层<strong>不做字段名归一和字段类型统一的操作，如果需要使用兼容的数据类型</strong></li>
<li>对于增量表，需要设计增量表(ODS_业务系统_表名_delta)和全量表,然后将增量表合并成全量表数据</li>
<li>对于半结构化数据需要设计解析</li>
<li>由于业务数据库（OLTP）基本按照ER实体模型建模，因此ODS层中的建模方式也是<strong>ER实体模型</strong></li>
</ul>
<blockquote>
<p>ods 的设计可以保证所有的数据按照统一的规范进行存储。</p>
</blockquote>
<h4 id="统一数仓层dw">统一数仓层(DW)</h4>
<ul>
<li>是数据仓库的主体.在这里，从ODS层中获得的数据按照主题建立各种数据模型。</li>
<li>这一层和维度建模会有比较深的联系，业务数据是按照<strong>业务流程方便操作的角度</strong>来组织数据的，而统一数仓层是<strong>按照业务易理解的角度</strong>进行数据组织的。</li>
<li>定义了一致的指标、维度，各业务板块、数据域都是按照统一的规范来建设，从而形成统一规范的<strong>标准业务数据体系</strong></li>
<li>它们通常都是基于Kimball的维度建模理论来构建的，<strong>并通过一致性维度和数据总线来保证各个子主题的维度一致性</strong>。</li>
</ul>
<blockquote>
<p>如果 ods 层的数据就非常规整，基本能满足我们绝大部分的需求，这当然是好的，这时候dwd层其实也没太大必要。但是现实中接触的情况是 ods 层的数据很难保证质量，毕竟数据的来源多种多样，推送方也会有自己的推送逻辑，在这种情况下，我们就需要通过额外的一层 dwd 来屏蔽一些底层的差异。</p>
</blockquote>
<h5 id="设计原则">设计原则</h5>
<h6 id="一致性维度规范">一致性维度规范</h6>
<ul>
<li>公共层的维度表中相同维度属性在不同物理表中的字段名称、数据类型、数据内容必须保持一致</li>
</ul>
<h6 id="维度的组合与拆分">维度的组合与拆分</h6>
<ul>
<li>将维度所描述业务相关性强的字段在一个物理维表实现。相关性强是指经常需要一起查询或进行报表展现、两个维度属性间是否存在天然的关系等。例如，商品基本属性和所属品牌。</li>
</ul>
<h5 id="dwd">DWD</h5>
<ul>
<li>公告明细数据层</li>
<li>DWD层要做的就是将<strong>数据清理、整合、规范化、脏数据、垃圾数据、规范不一致的、状态定义不一致的、命名不规范的数据都会被处理</strong>。</li>
<li>DWD层应该是覆盖所有系统的、完整的、干净的、具有一致性的数据层。在DWD层会根据维度模型，设计事实表和维度表，也就是说DWD层是一个非常规范的、高质量的、可信的数据明细层。</li>
</ul>
<h5 id="dws">DWS</h5>
<ul>
<li>DWS层为<strong>公共汇总层</strong>，会进行轻度汇总，粒度比明细数据稍粗，<strong>基于DWD层上的基础数据，整合汇总成分析某一个主题域的服务数据</strong>，一般是宽表。</li>
<li>DWS层应覆盖80%的应用场景</li>
</ul>
<h4 id="dim-层">DIM 层</h4>
<ul>
<li>维表层</li>
<li>稳定维度维表，渐变维度维表</li>
</ul>
<h5 id="维度表-2">维度表</h5>
<ul>
<li><strong>维度指的是观察事物的角度，提供某一业务过程事件涉及用什么过滤和分类的描述属性</strong>，&quot;谁、什么时候、什么地点、为什么、如何&quot;干了什么，维度表示维度建模的基础和灵魂</li>
<li>比如，&quot;小王早上在小卖部花费5元钱购买了包子&quot;，时间维度——早上，地点维度——小卖部，商品维度——包子</li>
<li>维度表包含了业务过程记录的业务过程度量的上下文和环境。维度表都包含单一的主键列，<strong>维度表设计的核心是确定维度字段，维度字段是查询约束条件(where)、分组条件(group)、排序(order)，与报表标签的基本来源</strong>。</li>
<li>维度表通常比较宽**，包含多个属性、是扁平的规范表**，实际应用中包含几十个或者上百个属性的维度并不少见，维度表应该包括一些<strong>有意义的描述</strong>，方便下游使用</li>
<li>维度表的维度属性，应该尽可能的丰富，所以维度表中，经常出现一些反范式的设计，把维度属性并到主维度属性中，达到易用少关联的效果。</li>
<li>维度表的设计包括维度选择，主维表的确定，梳理关联维度，定义维度属性的过程</li>
<li>维度的选择一般从报表需求和从业务人员的交谈中发现，主要用于过滤、分组、排序</li>
<li>主维度表一般从业务库直接同步，比如用户表</li>
<li>关联维度主要是不同业务系统或者同一业务系统的表之间存在关联性(范式建模)，根据对业务表的梳理，确定哪些表和主维度表之间存在关联关系，并选择其中的某些表用于生成维度属性。</li>
</ul>
<h5 id="渐变维度维表">渐变维度维表</h5>
<ul>
<li>维度数据会随着时间发生变化，变化速度非常缓慢。eg：电商平台的用户维度表，用户的收货地址是缓慢变化的。</li>
</ul>
<h4 id="标签数据层tdm">标签数据层(TDM)</h4>
<ul>
<li>面向对象建模，对跨业务板块、跨数据域的特定对象进行数据整合，通过统一的ID-Mapping 把各个业务板块，各个业务过程中<strong>同一对象的数据打通</strong>，形成对象的全域数据标签体系，方便深度分析、挖掘、应用。</li>
</ul>
<h5 id="标签的分类">标签的分类</h5>
<ul>
<li>标签按照产生和计算方式的不同可分为属性标签，统计标签，算法标签，关联标签</li>
</ul>
<h6 id="属性标签">属性标签</h6>
<ul>
<li>对象本身的性质就是属性标签</li>
</ul>
<h6 id="统计标签">统计标签</h6>
<ul>
<li>对象在业务过程中产生的原子指标，通过不同的计算方法可以生成统计标签</li>
</ul>
<h6 id="算法标签">算法标签</h6>
<ul>
<li>对象在多个业务过程中的特征规律通过一定的算法产出的标签</li>
</ul>
<h6 id="关联标签">关联标签</h6>
<ul>
<li>对象在特定的业务过程会和其他对象关联，关联对象的标签也可以打在主对象上</li>
</ul>
<h5 id="对象标识">对象标识</h5>
<ul>
<li>对象的标识可以标识一个对象，一般是对象的ID,比如手机号，身份证，登录账号</li>
</ul>
<h5 id="标签">标签</h5>
<ul>
<li>利用原始数据，通过一定的逻辑加工产出直接能被业务所直接使用的、可阅读的，有价值的数据。</li>
</ul>
<h5 id="标签类目">标签类目</h5>
<ul>
<li>是标签的分类组织方式，是标签信息的一种结构化描述，目的是管理、查找，一般采用多级类目</li>
<li>一般当标签的个数超过50个的时候，业务人员查找标签就会变得非常麻烦，</li>
</ul>
<h5 id="id-mapping">ID-Mapping</h5>
<blockquote>
<p>一个自然人他有身份证号码进行唯一标识，但是在医保的时候他使用的实医保账号，缴纳水电费的时候又是不同的账号，使用手机的时候又是设备账号，上网的时候是网商账号。</p>
</blockquote>
<ul>
<li>在确认对象后，由于同一对象在不同的业务体系中的对象标识是不一样的，因此需要将同一对象上的不同ID  标识打通，以便所有的业务数据都能够在该对象上打通。</li>
<li>完成对象的ID 打通需要给对象设置一个超级ID,需要根据对象当前业务体系的ID和获取得到或者计算得到超级ID,进而完成所有业务标识的ID打通</li>
<li>一般来说ID 打通是建设标签体系的前提，如果没有ID打通就无法收集到一个对象的全面信息，也就无法对这个对象进行全面的标签刻画。</li>
</ul>
<h6 id="id-mapping-的计算">ID-Mapping 的计算</h6>
<ul>
<li>传统的计算方法要有 ID-ID 之间的两两关系，例如邮箱和手机号可以打通，手机号和身份证号可以打通，那么邮箱就和身份证号可以打通，但是当数据量非常大，且业务板块非常多的时候，例如有上一个对象，每个对象有数十种ID,这个时候打通就需要非常漫长的计算</li>
</ul>
<h4 id="ads-层">ADS 层</h4>
<ul>
<li>数仓层，DIM 层，TDM 层是相对稳定的，所以无法满足灵活多变业务需求，所以这和数仓层的规范和划分相矛盾，所以我们在此基础上建立了另外一个层，这就是ADS 层，解决了规划稳定和灵活多变之间的矛盾。</li>
<li>数据应用层，按照业务的需要从统一数仓层和DIM进行取数，并面向业务的特殊需求对数据进行加工,以满足业务和性能的需求。</li>
<li>ADS 层因为面向的实众多的需求，所以这一层没有太多的规范，只需要按照命名规范来进行就可以了</li>
</ul>
<h5 id="ads-层设计">ADS 层设计</h5>
<ul>
<li>ADS 层的建设是强业务推动的，业务部门需要参与到ADS 的建设中来</li>
</ul>
<h6 id="实现流程">实现流程</h6>
<ul>
<li>理清需求，了解业务方对数据内容、使用方式(怎么交互的，报表、接口、即席查询、在线查询、指标查询、搜索)、性能的要求</li>
<li>盘点现有的数仓表是否可以支持</li>
<li>代码实现，选择合适的存储引擎和查询引擎</li>
</ul>
<h6 id="使用场景与性能">使用场景与性能</h6>
<ul>
<li>针对业务方的使用场景，我们需要设计出高效，满足要求的ADS 层表</li>
<li>如果是多维分析，为了减少连接，提升性能，我们一般采用大宽表设计，使用高性能引擎支撑</li>
<li>如果是特定指标查询，一般采用KV的形式组织</li>
<li>如果是搜索场景，一般采用搜索引擎</li>
</ul>
<h4 id="dm-层数据集市层">DM 层数据集市层</h4>
<ul>
<li>主要是提供数据产品和数据分析的数据，一般会存放在ES、Mysql、也可能直接存储在hive中或者druid供数据分析和数据挖掘使用。</li>
<li>主要<strong>解决部门用户报表和分析需求</strong>而建立数据库，数据集市就代表数据仓库的主题域</li>
</ul>
<h3 id="模型落地实现">模型落地实现</h3>
<ol>
<li>按照命名规范创建表</li>
<li>开发生成维表和事实表的代码</li>
<li>进行代码逻辑测试，验证数据加工逻辑的正确性</li>
<li>代码发布，加入调度并配置相应的质量监控和报警机制</li>
</ol>
<h2 id="总线矩阵核心概念">(总线矩阵)核心概念</h2>
<h3 id="业务板块"><strong>业务板块</strong></h3>
<ul>
<li>根据业务属性划分出相对独立的业务板块，业务板块是一种<strong>很大的划分</strong>，各个业务板块<strong>重叠度非常低</strong>，<strong>数据独立建设</strong>，比如地产板块、金融板块、医疗板块、电商板块</li>
</ul>
<h3 id="模型设计"><strong>模型设计</strong></h3>
<ul>
<li>以维度建模为理论基础，基于维度建模的总线架构，<strong>构建一致性的维度表和事实表，同时设计出一套命名规范</strong></li>
</ul>
<h3 id="数据域"><strong>数据域</strong></h3>
<ul>
<li>数据域是<strong>数仓层的顶层划分</strong>，是一个<strong>较高层次的数据归类标准</strong>，是<strong>对企业的各个业务过程进行抽象、提炼、组合成的集合，面向业务分析</strong></li>
<li>一个数据域对应一个宏观分析领域，例如采购域、供应链域、学生域、老师域、CR域、CC域、排课域</li>
<li>数据域是抽象提炼出来的，并且不容易变动，既能涵盖当前所有业务需求，又能在新的业务进入时无影响的将其分配到已有的数据域，只有当前数据域分类都不合适的时候才会扩展到新的数据域</li>
<li>数据域的特点是抽象、长期维护和更新、但是不宜变更</li>
</ul>
<blockquote>
<p>为保障整个体系的生命力，数据域是需要抽象提炼并且长期维护更新的，但不轻易变动。在划分数据域时，既要能涵盖所有业务需求，又能在新业务进入时无影响的包含已有的数据还要扩展新的数据域。</p>
</blockquote>
<ul>
<li>数据域的创建需要经过这样几个流程，第一数据调研(业务调研)，第二业务分类，第三数据域定义(数据域的名称)，第四总线矩阵构建</li>
</ul>
<table>
<thead>
<tr>
<th>域名</th>
<th>业务过程</th>
</tr>
</thead>
<tbody>
<tr>
<td>会员域</td>
<td>会员注册、登录、退出、冻结、注销</td>
</tr>
<tr>
<td>商品域</td>
<td>商品发布、上架、下架、属性变更</td>
</tr>
<tr>
<td>日志域</td>
<td>曝光、点击、浏览、收藏、滑动、搜索</td>
</tr>
</tbody>
</table>
<h3 id="业务过程">业务过程</h3>
<ul>
<li>业务过程是企业的业务活动事件，且是企业经营过程中不可拆分的事件，比如下订单、账号注册、银行转账都是业务过程</li>
</ul>
<h3 id="修饰词">修饰词</h3>
<ul>
<li>修饰词指的是出统计指标以外的对指标进行限定抽象的业务场景，修饰词属于一个修饰类型，比如值日志域的访问终端下，有修饰词PC,w无线端、手机端，IOS</li>
<li>修饰词的出现是为了方便管理</li>
</ul>
<h3 id="时间周期">时间周期</h3>
<ul>
<li>用来明确数据统计的时间范围或时间点</li>
</ul>
<h3 id="原子指标">原子指标</h3>
<ul>
<li>原子指标是针对某一业务的<strong>行为的度量</strong>，是一种不可拆分的指标，有明确的业务含义，比如支付金额，注册用户数</li>
<li>原子指标有确定的字段名称，数据类型，算法说明，所属数据域和业务过程，原子指标一般采用<strong>动作_度量</strong>的方式命名，例如注册学生</li>
</ul>
<h3 id="一致性指标扩展指标">一致性指标(扩展指标)</h3>
<ul>
<li>指标归属到具体的数据域，指标的定义、名称、类型、计算方法，确保指标的全局一致性</li>
<li>一致性指标用来描述原子指标、修饰词、时间周期和派生指标的含义、类型、命名、算法，被用于模型设计</li>
<li>一致性指标=原子指标+时间修饰词+其他修饰词，例如 最近7天(时间修饰词)支付(其他修饰词)积分，最近1月注册用户数</li>
</ul>
<h3 id="计算方法">计算方法</h3>
<ul>
<li>指标的数学计算公式，比如汇总、平均、最值</li>
</ul>
<h3 id="事实表-2">事实表</h3>
<ul>
<li>事实表是观察事物得到的事实数据，事实设计来自业务过程事件的描述，例如一次购买行为</li>
<li>事实表是数仓建设的主要产物，数仓绝大部分都是事实表，事实表主要由两部分组成，第一部分主键和外键组成的键值部分，第二部分加事实明细组成，外键通常对应维度表的主键。</li>
</ul>
<h3 id="olap">OLAP</h3>
<h4 id="rolap">ROLAP</h4>
<ul>
<li>基于关系型数据库，不需要预计算</li>
<li>加快速度的方式主要是使用内存和优化算法(presto,impala)</li>
</ul>
<h4 id="moalp">MOALP</h4>
<ul>
<li>基于多维数据集，需要预计算，加快速度的方式是预计算</li>
<li>一个多维数据集叫做 OLAP CUBE</li>
</ul>
<h5 id="钻取">钻取</h5>
<ul>
<li>钻取是改变维的层次，变换分析的粒度。它包括向上钻取（roll up）和向下钻取（drill down）</li>
</ul>
<h6 id="roll-up">roll up</h6>
<ul>
<li>roll up是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数(从小到大)</li>
<li>是指自动生成汇总行的分析方法。通过向导的方式，用户可以定义分析因素的汇总行，例如对于各地区各年度的销售情况，可以生成地区与年度的合计行，也可以生成地区或者年度的合计行</li>
</ul>
<h6 id="drill-down">drill down</h6>
<ul>
<li>rill down则相反，它从汇总数据深入到细节数据进行观察或增加新维(从大到小)</li>
<li>例如，用户分析&quot;各地区、城市的销售情况&quot;时，可以对某一个城市的销售额细分为各个年度的销售额，对某一年度的销售额，可以继续细分为各个季度的销售额。通过钻取的功能，使用户对数据能更深入了解，更容易发现问题，做出正确的决策</li>
</ul>
<h2 id="建模工具">建模工具</h2>
<h3 id="navicate">navicate</h3>
<h4 id="利用已有的表进行">利用已有的表进行</h4>
<figure data-type="image" tabindex="5"><img src="BCE1DE43CA9D4F748FA013E85B4009C3" alt="image" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="762F4CEFD6394422988B30AE66423DAE" alt="image" loading="lazy"></figure>
<h4 id="建立新的模型图">建立新的模型图</h4>
<figure data-type="image" tabindex="7"><img src="C82827BEE31645089015A9C3E65C8098" alt="image" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统设计入门]]></title>
        <id>https://kingcall.github.io/post/xi-tong-she-ji-ru-men/</id>
        <link href="https://kingcall.github.io/post/xi-tong-she-ji-ru-men/">
        </link>
        <updated>2020-08-18T13:23:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://github.com/donnemartin/system-design-primer">github.com/donnemartin/system-design-primer</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/XatMassacrE">XatMassacrE</a>、<a href="https://github.com/L9m">L9m</a>、<a href="https://github.com/Airmacho">Airmacho</a>、<a href="https://github.com/xiaoyusilen">xiaoyusilen</a>、<a href="https://github.com/jifaxu">jifaxu</a></li>
<li>这个 <a href="https://github.com/xitu/system-design-primer/compare/master...donnemartin:master">链接</a> 用来查看本翻译与英文版是否有差别（如果你没有看到 README.md 发生变化，那就意味着这份翻译文档是最新的）。</li>
</ul>
</blockquote>
<p align="center">
  <img src="http://i.imgur.com/jj3A5N8.png">
  <br/>
</p>
<h2 id="翻译">翻译</h2>
<p>有兴趣参与<a href="https://github.com/donnemartin/system-design-primer/issues/28">翻译</a>?  以下是正在进行中的翻译:</p>
<ul>
<li><a href="https://github.com/donnemartin/system-design-primer/issues/40">巴西葡萄牙语</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer/issues/38">简体中文</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer/issues/39">土耳其语</a></li>
</ul>
<h2 id="目的">目的</h2>
<blockquote>
<p>学习如何设计大型系统。</p>
<p>为系统设计的面试做准备。</p>
</blockquote>
<h3 id="学习如何设计大型系统">学习如何设计大型系统</h3>
<p>学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。</p>
<p>系统设计是一个很宽泛的话题。在互联网上，<strong>关于系统设计原则的资源也是多如牛毛。</strong></p>
<p>这个仓库就是这些资源的<strong>组织收集</strong>，它可以帮助你学习如何构建可扩展的系统。</p>
<h3 id="从开源社区学习">从开源社区学习</h3>
<p>这是一个不断更新的开源项目的初期的版本。</p>
<p>欢迎<a href="#%E8%B4%A1%E7%8C%AE">贡献</a>！</p>
<h3 id="为系统设计的面试做准备">为系统设计的面试做准备</h3>
<p>在很多科技公司中，除了代码面试，系统设计也是<strong>技术面试过程</strong>中的一个<strong>必要环节</strong>。</p>
<p><strong>实践常见的系统设计面试题</strong>并且把你的答案和<strong>例子的解答</strong>进行<strong>对照</strong>：讨论，代码和图表。</p>
<p>面试准备的其他主题：</p>
<ul>
<li><a href="#%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%BC%95">学习指引</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">如何处理一个系统设计的面试题</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E8%A7%A3%E7%AD%94">系统设计的面试题，<strong>含解答</strong></a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94">面向对象设计的面试题，<strong>含解答</strong></a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98">其它的系统设计面试题</a></li>
</ul>
<h2 id="抽认卡">抽认卡</h2>
<p align="center">
  <img src="http://i.imgur.com/zdCAkB3.png">
  <br/>
</p>
<p>这里提供的<a href="https://apps.ankiweb.net/">抽认卡堆</a>使用间隔重复的方法，帮助你记忆关键的系统设计概念。</p>
<ul>
<li><a href="resources/flash_cards/System%20Design.apkg">系统设计的卡堆</a></li>
<li><a href="resources/flash_cards/System%20Design%20Exercises.apkg">系统设计的练习卡堆</a></li>
<li><a href="resources/flash_cards/OO%20Design.apkg">面向对象设计的练习卡堆</a></li>
</ul>
<p>随时随地都可使用。</p>
<h3 id="代码资源互动式编程挑战">代码资源：互动式编程挑战</h3>
<p>你正在寻找资源以准备<a href="https://github.com/donnemartin/interactive-coding-challenges"><strong>编程面试</strong></a>吗？</p>
<p align="center">
  <img src="http://i.imgur.com/b4YtAEN.png">
  <br/>
</p>
<p>请查看我们的姐妹仓库<a href="https://github.com/donnemartin/interactive-coding-challenges"><strong>互动式编程挑战</strong></a>，其中包含了一个额外的抽认卡堆：</p>
<ul>
<li><a href="https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg">代码卡堆</a></li>
</ul>
<h2 id="贡献">贡献</h2>
<blockquote>
<p>从社区中学习。</p>
</blockquote>
<p>欢迎提交 PR 提供帮助：</p>
<ul>
<li>修复错误</li>
<li>完善章节</li>
<li>添加章节</li>
</ul>
<p>一些还需要完善的内容放在了<a href="#%E6%AD%A3%E5%9C%A8%E5%AE%8C%E5%96%84%E4%B8%AD">正在完善中</a>。</p>
<p>请查看<a href="CONTRIBUTING.md">贡献指南</a>。</p>
<h2 id="系统设计主题的索引">系统设计主题的索引</h2>
<blockquote>
<p>各种系统设计主题的摘要，包括优点和缺点。<strong>每一个主题都面临着取舍和权衡</strong>。</p>
<p>每个章节都包含着更多的资源的链接。</p>
</blockquote>
<p align="center">
  <img src="http://i.imgur.com/jrUBAF7.png">
  <br/>
</p>
<ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B">系统设计主题：从这里开始</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%9B%9E%E9%A1%BE%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7scalability%E7%9A%84%E8%A7%86%E9%A2%91%E8%AE%B2%E5%BA%A7">第一步：回顾可扩展性的视频讲座</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%9B%9E%E9%A1%BE%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E6%96%87%E7%AB%A0">第二步：回顾可扩展性的文章</a></li>
<li><a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E6%AD%A5%E9%AA%A4">接下来的步骤</a></li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">性能与拓展性</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E4%B8%8E%E5%90%9E%E5%90%90%E9%87%8F">延迟与吞吐量</a></li>
<li><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7">可用性与一致性</a>
<ul>
<li><a href="#cap-%E7%90%86%E8%AE%BA">CAP 理论</a>
<ul>
<li><a href="#cp--%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7">CP - 一致性和分区容错性</a></li>
<li><a href="#ap--%E5%8F%AF%E7%94%A8%E6%80%A7%E4%B8%8E%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7">AP - 可用性和分区容错性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%BC%8F">一致模式</a>
<ul>
<li><a href="#%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7">弱一致性</a></li>
<li><a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></li>
<li><a href="#%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7">强一致性</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A8%A1%E5%BC%8F">可用模式</a>
<ul>
<li><a href="#%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2">故障切换</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6">复制</a></li>
</ul>
</li>
<li><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统</a></li>
<li><a href="#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9Ccdn">CDN</a>
<ul>
<li><a href="#cdn-%E6%8E%A8%E9%80%81push">CDN 推送</a></li>
<li><a href="#cdn-%E6%8B%89%E5%8F%96pull">CDN 拉取</a></li>
</ul>
</li>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8">负载均衡器</a>
<ul>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%88%B0%E5%A4%87%E7%94%A8%E5%88%87%E6%8D%A2active-passive">工作到备用切换（Active-passive）</a></li>
<li><a href="#%E5%8F%8C%E5%B7%A5%E4%BD%9C%E5%88%87%E6%8D%A2active-active">双工作切换（Active-active）</a></li>
<li><a href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">四层负载均衡</a></li>
<li><a href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8">七层负载均衡</a></li>
<li><a href="#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95">水平扩展</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">反向代理（web 服务器）</a>
<ul>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">负载均衡与反向代理</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>
<ul>
<li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0">服务发现</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>
<ul>
<li><a href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Frdbms">关系型数据库管理系统（RDBMS）</a>
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">Master-slave 复制集</a></li>
<li><a href="#%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6">Master-master 复制集</a></li>
<li><a href="#%E8%81%94%E5%90%88">联合</a></li>
<li><a href="#%E5%88%86%E7%89%87">分片</a></li>
<li><a href="#%E9%9D%9E%E8%A7%84%E8%8C%83%E5%8C%96">非规范化</a></li>
<li><a href="#sql-%E8%B0%83%E4%BC%98">SQL 调优</a></li>
</ul>
</li>
<li><a href="#nosql">NoSQL</a>
<ul>
<li><a href="#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8">Key-value 存储</a></li>
<li><a href="#%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8">文档存储</a></li>
<li><a href="#%E5%88%97%E5%9E%8B%E5%AD%98%E5%82%A8">宽列存储</a></li>
<li><a href="#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93">图数据库</a></li>
</ul>
</li>
<li><a href="#sql-%E8%BF%98%E6%98%AF-nosql">SQL 还是 NoSQL</a></li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98">客户端缓存</a></li>
<li><a href="#cdn-%E7%BC%93%E5%AD%98">CDN 缓存</a></li>
<li><a href="#web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98">Web 服务器缓存</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98">数据库缓存</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98">应用缓存</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BC%93%E5%AD%98">数据库查询级别的缓存</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BC%93%E5%AD%98">对象级别的缓存</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98">何时更新缓存</a>
<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F">缓存模式</a></li>
<li><a href="#%E7%9B%B4%E5%86%99%E6%A8%A1%E5%BC%8F">直写模式</a></li>
<li><a href="#%E5%9B%9E%E5%86%99%E6%A8%A1%E5%BC%8F">回写模式</a></li>
<li><a href="#%E5%88%B7%E6%96%B0">刷新</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5">异步</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">任务队列</a></li>
<li><a href="#%E8%83%8C%E5%8E%8B">背压机制</a></li>
</ul>
</li>
<li><a href="#%E9%80%9A%E8%AE%AF">通讯</a>
<ul>
<li><a href="#%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AEtcp">传输控制协议（TCP）</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp">用户数据报协议（UDP）</a></li>
<li><a href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AErpc">远程控制调用协议（RPC）</a></li>
<li><a href="#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBrest">表述性状态转移（REST）</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8">安全</a></li>
<li><a href="#%E9%99%84%E5%BD%95">附录</a>
<ul>
<li><a href="#2-%E7%9A%84%E6%AC%A1%E6%96%B9%E8%A1%A8">2 的次方表</a></li>
<li><a href="#%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%95%B0">每个程序员都应该知道的延迟数</a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98">其它的系统设计面试题</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E6%9E%B6%E6%9E%84">真实架构</a></li>
<li><a href="#%E5%85%AC%E5%8F%B8%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">公司的系统架构</a></li>
<li><a href="#%E5%85%AC%E5%8F%B8%E5%B7%A5%E7%A8%8B%E5%8D%9A%E5%AE%A2">公司工程博客</a></li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%9C%A8%E5%AE%8C%E5%96%84%E4%B8%AD">正在完善中</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
<li><a href="#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F">联系方式</a></li>
<li><a href="#%E8%AE%B8%E5%8F%AF">许可</a></li>
</ul>
<h2 id="学习指引">学习指引</h2>
<blockquote>
<p>基于你面试的时间线（短、中、长）去复习那些推荐的主题。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="http://i.imgur.com/OfVllex.png" alt="Imgur" loading="lazy"></figure>
<p><strong>问：对于面试来说，我需要知道这里的所有知识点吗？</strong></p>
<p><strong>答：不，如果只是为了准备面试的话，你并不需要知道所有的知识点。</strong></p>
<p>在一场面试中你会被问到什么取决于下面这些因素：</p>
<ul>
<li>你的经验</li>
<li>你的技术背景</li>
<li>你面试的职位</li>
<li>你面试的公司</li>
<li>运气</li>
</ul>
<p>那些有经验的候选人通常会被期望了解更多的系统设计的知识。架构师或者团队负责人则会被期望了解更多除了个人贡献之外的知识。顶级的科技公司通常也会有一次或者更多的系统设计面试。</p>
<p>面试会很宽泛的展开并在几个领域深入。这会帮助你了解一些关于系统设计的不同的主题。基于你的时间线，经验，面试的职位和面试的公司对下面的指导做出适当的调整。</p>
<ul>
<li><strong>短期</strong> - 以系统设计主题的<strong>广度</strong>为目标。通过解决<strong>一些</strong>面试题来练习。</li>
<li><strong>中期</strong> - 以系统设计主题的<strong>广度</strong>和<strong>初级深度</strong>为目标。通过解决<strong>很多</strong>面试题来练习。</li>
<li><strong>长期</strong> - 以系统设计主题的<strong>广度</strong>和<strong>高级深度</strong>为目标。通过解决<strong>大部分</strong>面试题来练习。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>短期</th>
<th>中期</th>
<th>长期</th>
</tr>
</thead>
<tbody>
<tr>
<td>阅读 <a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E7%9A%84%E7%B4%A2%E5%BC%95">系统设计主题</a> 以获得一个关于系统如何工作的宽泛的认识</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>阅读一些你要面试的<a href="#%E5%85%AC%E5%8F%B8%E5%B7%A5%E7%A8%8B%E5%8D%9A%E5%AE%A2">公司工程博客</a>的文章</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>阅读 <a href="#%E7%9C%9F%E5%AE%9E%E6%9E%B6%E6%9E%84">真实架构</a></td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>复习 <a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98">如何处理一个系统设计面试题</a></td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>完成 <a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E8%A7%A3%E7%AD%94">系统设计的面试题和解答</a></td>
<td>一些</td>
<td>很多</td>
<td>大部分</td>
</tr>
<tr>
<td>完成 <a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94">面向对象设计的面试题和解答</a></td>
<td>一些</td>
<td>很多</td>
<td>大部分</td>
</tr>
<tr>
<td>复习 <a href="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98">其它的系统设计面试题</a></td>
<td>一些</td>
<td>很多</td>
<td>大部分</td>
</tr>
</tbody>
</table>
<h2 id="如何处理一个系统设计的面试题">如何处理一个系统设计的面试题</h2>
<p>系统设计面试是一个<strong>开放式的对话</strong>。他们期望你去主导这个对话。</p>
<p>你可以使用下面的步骤来指引讨论。为了巩固这个过程，请使用下面的步骤完成<a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E8%A7%A3%E7%AD%94">系统设计的面试题和解答</a>这个章节。</p>
<h3 id="第一步描述使用场景约束和假设">第一步：描述使用场景，约束和假设</h3>
<p>把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。</p>
<ul>
<li>谁会使用它？</li>
<li>他们会怎样使用它？</li>
<li>有多少用户？</li>
<li>系统的作用是什么？</li>
<li>系统的输入输出分别是什么？</li>
<li>我们希望处理多少数据？</li>
<li>我们希望每秒钟处理多少请求？</li>
<li>我们希望的读写比率？</li>
</ul>
<h3 id="第二步创造一个高层级的设计">第二步：创造一个高层级的设计</h3>
<p>使用所有重要的组件来描绘出一个高层级的设计。</p>
<ul>
<li>画出主要的组件和连接</li>
<li>证明你的想法</li>
</ul>
<h3 id="第三步设计核心组件">第三步：设计核心组件</h3>
<p>对每一个核心组件进行详细深入的分析。举例来说，如果你被问到<a href="solutions/system_design/pastebin/README.md">设计一个 url 缩写服务</a>，开始讨论：</p>
<ul>
<li>生成并储存一个完整 url 的 hash
<ul>
<li><a href="solutions/system_design/pastebin/README.md">MD5</a> 和 <a href="solutions/system_design/pastebin/README.md">Base62</a></li>
<li>Hash 碰撞</li>
<li>SQL 还是 NoSQL</li>
<li>数据库模型</li>
</ul>
</li>
<li>将一个 hashed url 翻译成完整的 url
<ul>
<li>数据库查找</li>
</ul>
</li>
<li>API 和面向对象设计</li>
</ul>
<h3 id="第四步扩展设计">第四步：扩展设计</h3>
<p>确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？</p>
<ul>
<li>负载均衡</li>
<li>水平扩展</li>
<li>缓存</li>
<li>数据库分片</li>
</ul>
<p>论述可能的解决办法和代价。每件事情需要取舍。可以使用<a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E7%9A%84%E7%B4%A2%E5%BC%95">可扩展系统的设计原则</a>来处理瓶颈。</p>
<h3 id="预估计算量">预估计算量</h3>
<p>你或许会被要求通过手算进行一些估算。<a href="#%E9%99%84%E5%BD%95">附录</a>涉及到的是下面的这些资源：</p>
<ul>
<li><a href="http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html">使用预估计算量</a></li>
<li><a href="#2-%E7%9A%84%E6%AC%A1%E6%96%B9%E8%A1%A8">2 的次方表</a></li>
<li><a href="#%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%95%B0">每个程序员都应该知道的延迟数</a></li>
</ul>
<h3 id="相关资源和延伸阅读">相关资源和延伸阅读</h3>
<p>查看下面的链接以获得我们期望的更好的想法：</p>
<ul>
<li><a href="https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/">怎样通过一个系统设计的面试</a></li>
<li><a href="http://www.hiredintech.com/system-design">系统设计的面试</a></li>
<li><a href="https://www.youtube.com/watch?v=ZgdS0EUmn70">系统架构与设计的面试简介</a></li>
</ul>
<h2 id="系统设计的面试题和解答">系统设计的面试题和解答</h2>
<blockquote>
<p>普通的系统设计面试题和相关事例的论述，代码和图表。</p>
</blockquote>
<blockquote>
<p>与内容有关的解答在 <code>solutions/</code> 文件夹中。</p>
</blockquote>
<table>
<thead>
<tr>
<th>问题</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设计 Pastebin.com (或者 Bit.ly)</td>
<td><a href="solutions/system_design/pastebin/README.md">解答</a></td>
</tr>
<tr>
<td>设计 Twitter 时间线和搜索 (或者 Facebook feed 和搜索)</td>
<td><a href="solutions/system_design/twitter/README.md">解答</a></td>
</tr>
<tr>
<td>设计一个网页爬虫</td>
<td><a href="solutions/system_design/web_crawler/README.md">解答</a></td>
</tr>
<tr>
<td>设计 Mint.com</td>
<td><a href="solutions/system_design/mint/README.md">解答</a></td>
</tr>
<tr>
<td>为一个社交网络设计数据结构</td>
<td><a href="solutions/system_design/social_graph/README.md">解答</a></td>
</tr>
<tr>
<td>为搜索引擎设计一个 key-value 储存</td>
<td><a href="solutions/system_design/query_cache/README.md">解答</a></td>
</tr>
<tr>
<td>通过分类特性设计 Amazon 的销售排名</td>
<td><a href="solutions/system_design/sales_rank/README.md">解答</a></td>
</tr>
<tr>
<td>在 AWS 上设计一个百万用户级别的系统</td>
<td><a href="solutions/system_design/scaling_aws/README.md">解答</a></td>
</tr>
<tr>
<td>添加一个系统设计问题</td>
<td><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></td>
</tr>
</tbody>
</table>
<h3 id="设计-pastebincom-或者-bitly">设计 Pastebin.com (或者 Bit.ly)</h3>
<p><a href="solutions/system_design/pastebin/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="2"><img src="http://i.imgur.com/4edXG0T.png" alt="Imgur" loading="lazy"></figure>
<h3 id="设计-twitter-时间线和搜索-或者-facebook-feed-和搜索">设计 Twitter 时间线和搜索 (或者 Facebook feed 和搜索)</h3>
<p><a href="solutions/system_design/twitter/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="3"><img src="http://i.imgur.com/jrUBAF7.png" alt="Imgur" loading="lazy"></figure>
<h3 id="设计一个网页爬虫">设计一个网页爬虫</h3>
<p><a href="solutions/system_design/web_crawler/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="4"><img src="http://i.imgur.com/bWxPtQA.png" alt="Imgur" loading="lazy"></figure>
<h3 id="设计-mintcom">设计 Mint.com</h3>
<p><a href="solutions/system_design/mint/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="5"><img src="http://i.imgur.com/V5q57vU.png" alt="Imgur" loading="lazy"></figure>
<h3 id="为一个社交网络设计数据结构">为一个社交网络设计数据结构</h3>
<p><a href="solutions/system_design/social_graph/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="6"><img src="http://i.imgur.com/cdCv5g7.png" alt="Imgur" loading="lazy"></figure>
<h3 id="为搜索引擎设计一个-key-value-储存">为搜索引擎设计一个 key-value 储存</h3>
<p><a href="solutions/system_design/query_cache/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="7"><img src="http://i.imgur.com/4j99mhe.png" alt="Imgur" loading="lazy"></figure>
<h3 id="设计按类别分类的-amazon-销售排名">设计按类别分类的 Amazon 销售排名</h3>
<p><a href="solutions/system_design/sales_rank/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="8"><img src="http://i.imgur.com/MzExP06.png" alt="Imgur" loading="lazy"></figure>
<h3 id="在-aws-上设计一个百万用户级别的系统">在 AWS 上设计一个百万用户级别的系统</h3>
<p><a href="solutions/system_design/scaling_aws/README.md">查看实践与解答</a></p>
<figure data-type="image" tabindex="9"><img src="http://i.imgur.com/jj3A5N8.png" alt="Imgur" loading="lazy"></figure>
<h2 id="面向对象设计的面试问题及解答">面向对象设计的面试问题及解答</h2>
<blockquote>
<p>常见面向对象设计面试问题及实例讨论，代码和图表演示。</p>
<p>与内容相关的解决方案在 <code>solutions/</code> 文件夹中。</p>
</blockquote>
<blockquote>
<p><strong>注：此节还在完善中</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>问题</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设计 hash map</td>
<td><a href="solutions/object_oriented_design/hash_table/hash_map.ipynb">解决方案</a></td>
</tr>
<tr>
<td>设计 LRU 缓存</td>
<td><a href="solutions/object_oriented_design/lru_cache/lru_cache.ipynb">解决方案</a></td>
</tr>
<tr>
<td>设计一个呼叫中心</td>
<td><a href="solutions/object_oriented_design/call_center/call_center.ipynb">解决方案</a></td>
</tr>
<tr>
<td>设计一副牌</td>
<td><a href="solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb">解决方案</a></td>
</tr>
<tr>
<td>设计一个停车场</td>
<td><a href="solutions/object_oriented_design/parking_lot/parking_lot.ipynb">解决方案</a></td>
</tr>
<tr>
<td>设计一个聊天服务</td>
<td><a href="solutions/object_oriented_design/online_chat/online_chat.ipynb">解决方案</a></td>
</tr>
<tr>
<td>设计一个环形数组</td>
<td><a href="#%E8%B4%A1%E7%8C%AE">待解决</a></td>
</tr>
<tr>
<td>添加一个面向对象设计问题</td>
<td><a href="#%E8%B4%A1%E7%8C%AE">待解决</a></td>
</tr>
</tbody>
</table>
<h2 id="系统设计主题从这里开始">系统设计主题：从这里开始</h2>
<p>不熟悉系统设计？</p>
<p>首先，你需要对一般性原则有一个基本的认识，知道它们是什么，怎样使用以及利弊。</p>
<h3 id="第一步回顾可扩展性scalability的视频讲座">第一步：回顾可扩展性（scalability）的视频讲座</h3>
<p><a href="https://www.youtube.com/watch?v=-W9F__D3oY4">哈佛大学可扩展性讲座</a></p>
<ul>
<li>主题涵盖
<ul>
<li>垂直扩展（Vertical scaling）</li>
<li>水平扩展（Horizontal scaling）</li>
<li>缓存</li>
<li>负载均衡</li>
<li>数据库复制</li>
<li>数据库分区</li>
</ul>
</li>
</ul>
<h3 id="第二步回顾可扩展性文章">第二步：回顾可扩展性文章</h3>
<p><a href="http://www.lecloud.net/tagged/scalability/chrono">可扩展性</a></p>
<ul>
<li>主题涵盖：
<ul>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones">Clones</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database">数据库</a></li>
<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache">缓存</a></li>
<li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism">异步</a></li>
</ul>
</li>
</ul>
<h3 id="接下来的步骤">接下来的步骤</h3>
<p>接下来，我们将看看高阶的权衡和取舍:</p>
<ul>
<li><strong>性能</strong>与<strong>可扩展性</strong></li>
<li><strong>延迟</strong>与<strong>吞吐量</strong></li>
<li><strong>可用性</strong>与<strong>一致性</strong></li>
</ul>
<p>记住<strong>每个方面都面临取舍和权衡</strong>。</p>
<p>然后，我们将深入更具体的主题，如 DNS、CDN 和负载均衡器。</p>
<h2 id="性能与可扩展性">性能与可扩展性</h2>
<p>如果服务<strong>性能</strong>的增长与资源的增加是成比例的，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。<sup><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html">1</a></sup></p>
<p>另一个角度来看待性能与可扩展性:</p>
<ul>
<li>如果你的系统有<strong>性能</strong>问题，对于单个用户来说是缓慢的。</li>
<li>如果你的系统有<strong>可扩展性</strong>问题，单个用户较快但在高负载下会变慢。</li>
</ul>
<h3 id="来源及延伸阅读">来源及延伸阅读</h3>
<ul>
<li><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html">简单谈谈可扩展性</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">可扩展性，可用性，稳定性和模式</a></li>
</ul>
<h2 id="延迟与吞吐量">延迟与吞吐量</h2>
<p><strong>延迟</strong>是执行操作或运算结果所花费的时间。</p>
<p><strong>吞吐量</strong>是单位时间内（执行）此类操作或运算的数量。</p>
<p>通常，你应该以<strong>可接受级延迟</strong>下<strong>最大化吞吐量</strong>为目标。</p>
<h3 id="来源及延伸阅读-2">来源及延伸阅读</h3>
<ul>
<li><a href="https://community.cadence.com/cadence_blogs_8/b/sd/archive/2010/09/13/understanding-latency-vs-throughput">理解延迟与吞吐量</a></li>
</ul>
<h2 id="可用性与一致性">可用性与一致性</h2>
<h3 id="cap-理论">CAP 理论</h3>
<p align="center">
  <img src="http://i.imgur.com/bgLMI2u.png">
  <br/>
  <strong><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited">来源：再看 CAP 理论</a></strong>
</p>
<p>在一个分布式计算系统中，只能同时满足下列的两点:</p>
<ul>
<li><strong>一致性</strong> ─ 每次访问都能获得最新数据但可能会收到错误响应</li>
<li><strong>可用性</strong> ─ 每次访问都能收到非错响应，但不保证获取到最新数据</li>
<li><strong>分区容错性</strong> ─ 在任意分区网络故障的情况下系统仍能继续运行</li>
</ul>
<p><strong>网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。</strong></p>
<h4 id="cp-一致性和分区容错性">CP ─ 一致性和分区容错性</h4>
<p>等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。</p>
<h4 id="ap-可用性与分区容错性">AP ─ 可用性与分区容错性</h4>
<p>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。</p>
<p>如果业务需求允许<a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a>，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。</p>
<h3 id="来源及延伸阅读-3">来源及延伸阅读</h3>
<ul>
<li><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/">再看 CAP 理论</a></li>
<li><a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/">通俗易懂地介绍 CAP 理论</a></li>
<li><a href="https://github.com/henryr/cap-faq">CAP FAQ</a></li>
</ul>
<h2 id="一致性模式">一致性模式</h2>
<p>有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想 <a href="#cap-%E7%90%86%E8%AE%BA">CAP 理论</a>中的一致性定义 ─ 每次访问都能获得最新数据但可能会收到错误响应</p>
<h3 id="弱一致性">弱一致性</h3>
<p>在写入之后，访问可能看到，也可能看不到（写入数据）。尽力优化之让其能访问最新数据。</p>
<p>这种方式可以 memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。打个比方，如果你在通话中丢失信号几秒钟时间，当重新连接时你是听不到这几秒钟所说的话的。</p>
<h3 id="最终一致性">最终一致性</h3>
<p>在写入后，访问最终能看到写入数据（通常在数毫秒内）。数据被异步复制。</p>
<p>DNS 和 email 等系统使用的是此种方式。最终一致性在高可用性系统中效果不错。</p>
<h3 id="强一致性">强一致性</h3>
<p>在写入后，访问立即可见。数据被同步复制。</p>
<p>文件系统和关系型数据库（RDBMS）中使用的是此种方式。强一致性在需要记录的系统中运作良好。</p>
<h3 id="来源及延伸阅读-4">来源及延伸阅读</h3>
<ul>
<li><a href="http://snarfed.org/transactions_across_datacenters_io.html">Transactions across data centers</a></li>
</ul>
<h2 id="可用性模式">可用性模式</h2>
<p>有两种支持高可用性的模式: <strong>故障切换（fail-over）<strong>和</strong>复制（replication）</strong>。</p>
<h3 id="故障切换">故障切换</h3>
<h4 id="工作到备用切换active-passive">工作到备用切换（Active-passive）</h4>
<p>关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。</p>
<p>宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。</p>
<p>工作到备用的故障切换也被称为主从切换。</p>
<h4 id="双工作切换active-active">双工作切换（Active-active）</h4>
<p>在双工作切换中，双方都在管控流量，在它们之间分散负载。</p>
<p>如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。</p>
<p>双工作切换也可以称为主主切换。</p>
<h3 id="缺陷故障切换">缺陷：故障切换</h3>
<ul>
<li>故障切换需要添加额外硬件并增加复杂性。</li>
<li>如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。</li>
</ul>
<h3 id="复制">复制</h3>
<h4 id="主从复制和主主复制">主─从复制和主─主复制</h4>
<p>这个主题进一步探讨了<a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>部分:</p>
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">主─从复制</a></li>
<li><a href="#%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6">主─主复制</a></li>
</ul>
<h2 id="域名系统">域名系统</h2>
<p align="center">
  <img src="http://i.imgur.com/IOyLj4i.jpg">
  <br/>
  <strong><a href="http://www.slideshare.net/srikrupa5/dns-security-presentation-issa">来源：DNS 安全介绍</a></strong>
</p>
<p>域名系统是把 www.example.com 等域名转换成 IP 地址。</p>
<p>域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名） IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于<a href="https://en.wikipedia.org/wiki/Time_to_live">存活时间 TTL</a>。</p>
<ul>
<li><strong>NS 记录（域名服务）</strong> ─ 指定解析域名或子域名的 DNS 服务器。</li>
<li><strong>MX 记录（邮件交换）</strong> ─ 指定接收信息的邮件服务器。</li>
<li><strong>A 记录（地址）</strong> ─ 指定域名对应的 IP 地址记录。</li>
<li><strong>CNAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ example.com 指向 www.example.com ）或映射到一个 <code>A</code> 记录。</li>
</ul>
<p><a href="https://www.cloudflare.com/dns/">CloudFlare</a> 和 <a href="https://aws.amazon.com/route53/">Route 53</a> 等平台提供管理 DNS 的功能。某些 DNS 服务通过集中方式来路由流量:</p>
<ul>
<li><a href="http://g33kinfo.com/info/archives/2657">加权轮询调度</a>
<ul>
<li>防止流量进入维护中的服务器</li>
<li>在不同大小集群间负载均衡</li>
<li>A/B 测试</li>
</ul>
</li>
<li>基于延迟路由</li>
<li>基于地理位置路由</li>
</ul>
<h3 id="缺陷dns">缺陷:DNS</h3>
<ul>
<li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。</li>
<li>虽然它们通常由<a href="http://superuser.com/questions/472695/who-controls-the-dns-servers/472729">政府，网络服务提供商和大公司</a>管理，但 DNS 服务管理仍可能是复杂的。</li>
<li>DNS 服务最近遭受 <a href="http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/">DDoS 攻击</a>，阻止不知道 Twitter IP 地址的用户访问 Twitter。</li>
</ul>
<h3 id="来源及延伸阅读-5">来源及延伸阅读</h3>
<ul>
<li><a href="https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx">DNS 架构</a></li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Wikipedia</a></li>
<li><a href="https://support.dnsimple.com/categories/dns/">关于 DNS 的文章</a></li>
</ul>
<h2 id="内容分发网络cdn">内容分发网络（CDN）</h2>
<p align="center">
  <img src="http://i.imgur.com/h9TAuGI.jpg">
  <br/>
  <strong><a href="https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/">来源：为什么使用 CDN</a></strong>
</p>
<p>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。</p>
<p>将内容存储在 CDN 上可以从两个方面来提供性能:</p>
<ul>
<li>从靠近用户的数据中心提供资源</li>
<li>通过 CDN 你的服务器不必真的处理请求</li>
</ul>
<h3 id="cdn-推送push">CDN 推送（push）</h3>
<p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p>
<h3 id="cdn-拉取pull">CDN 拉取（pull）</h3>
<p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p>
<p><a href="https://en.wikipedia.org/wiki/Time_to_live">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p>
<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>
<h3 id="缺陷cdn">缺陷：CDN</h3>
<ul>
<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>
<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>
<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>
</ul>
<h3 id="来源及延伸阅读-6">来源及延伸阅读</h3>
<ul>
<li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci">全球性内容分发网络</a></li>
<li><a href="http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/">CDN 拉取和 CDN 推送的区别</a></li>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network">Wikipedia</a></li>
</ul>
<h2 id="负载均衡器">负载均衡器</h2>
<p align="center">
  <img src="http://i.imgur.com/h81n9iK.png">
  <br/>
  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">来源：可扩展的系统设计模式</a></strong>
</p>
<p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p>
<ul>
<li>防止请求进入不好的服务器</li>
<li>防止资源过载</li>
<li>帮助消除单一的故障点</li>
</ul>
<p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。<br>
增加的好处包括:</p>
<ul>
<li><strong>SSL 终结</strong> ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。
<ul>
<li>不需要再每台服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509">X.509 证书</a>。</li>
</ul>
</li>
<li><strong>Session 留存</strong> ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。</li>
</ul>
<p>通常会设置采用<a href="#%E5%B7%A5%E4%BD%9C%E5%88%B0%E5%A4%87%E7%94%A8%E5%88%87%E6%8D%A2active-passive">工作─备用</a> 或 <a href="#%E5%8F%8C%E5%B7%A5%E4%BD%9C%E5%88%87%E6%8D%A2active-active">双工作</a> 模式的多个负载均衡器，以免发生故障。</p>
<p>负载均衡器能基于多种方式来路由流量:</p>
<ul>
<li>随机</li>
<li>最少负载</li>
<li>Session/cookie</li>
<li><a href="http://g33kinfo.com/info/archives/2657">轮询调度或加权轮询调度算法</a></li>
<li><a href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">四层负载均衡</a></li>
<li><a href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">七层负载均衡</a></li>
</ul>
<h3 id="四层负载均衡">四层负载均衡</h3>
<p>四层负载均衡根据监看<a href="#%E9%80%9A%E8%AE%AF">传输层</a>的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行<a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/">网络地址转换（NAT）</a>来向上游服务器转发网络数据包。</p>
<h3 id="七层负载均衡器">七层负载均衡器</h3>
<p>七层负载均衡器根据监控<a href="#%E9%80%9A%E8%AE%AF">应用层</a>来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p>
<p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p>
<h3 id="水平扩展">水平扩展</h3>
<p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上<strong>垂直扩展</strong>更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p>
<h4 id="缺陷水平扩展">缺陷：水平扩展</h4>
<ul>
<li>水平扩展引入了复杂度并涉及服务器复制
<ul>
<li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li>
<li>session 可以集中存储在数据库或持久化<a href="#%E7%BC%93%E5%AD%98">缓存</a>（Redis、Memcached）的数据存储区中。</li>
</ul>
</li>
<li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li>
</ul>
<h3 id="缺陷负载均衡器">缺陷：负载均衡器</h3>
<ul>
<li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li>
<li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li>
<li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li>
</ul>
<h3 id="来源及延伸阅读-7">来源及延伸阅读</h3>
<ul>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt">HAProxy 架构指南</a></li>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones">可扩展性</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">Wikipedia</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/">四层负载平衡</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/">七层负载平衡</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html">ELB 监听器配置</a></li>
</ul>
<h2 id="反向代理web-服务器">反向代理（web 服务器）</h2>
<p align="center">
  <img src="http://i.imgur.com/n41Azff.png">
  <br/>
  <strong><a href="https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg">资料来源：维基百科</a></strong>
  <br/>
</p>
<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>
<p>带来的好处包括：</p>
<ul>
<li><strong>增加安全性</strong> - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>
<li><strong>提高可扩展性和灵活性</strong> - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>
<li><strong>本地终结 SSL 会话</strong> - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。
<ul>
<li>免除了在每个服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> 证书的需要</li>
</ul>
</li>
<li><strong>压缩</strong> - 压缩服务器响应</li>
<li><strong>缓存</strong> - 直接返回命中的缓存结果</li>
<li><strong>静态内容</strong> - 直接提供静态内容
<ul>
<li>HTML/CSS/JS</li>
<li>图片</li>
<li>视频</li>
<li>等等</li>
</ul>
</li>
</ul>
<h3 id="负载均衡器与反向代理">负载均衡器与反向代理</h3>
<ul>
<li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li>
<li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li>
<li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li>
</ul>
<h3 id="不利之处反向代理">不利之处：反向代理</h3>
<ul>
<li>引入反向代理会增加系统的复杂度。</li>
<li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如<a href="https://en.wikipedia.org/wiki/Failover">故障转移</a>）会进一步增加复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-8">来源及延伸阅读</h3>
<ul>
<li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/">反向代理与负载均衡</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt">HAProxy 架构指南</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reverse_proxy">Wikipedia</a></li>
</ul>
<h2 id="应用层">应用层</h2>
<p align="center">
  <img src="http://i.imgur.com/yB5SYwm.png">
  <br/>
  <strong><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer">资料来源：可缩放系统构架介绍</a></strong>
</p>
<p>将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p>
<p><strong>单一职责原则</strong>提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p>
<p>应用层中的工作进程也有可以实现<a href="#%E5%BC%82%E6%AD%A5">异步化</a>。</p>
<h3 id="微服务">微服务</h3>
<p>与此讨论相关的话题是 <a href="https://en.wikipedia.org/wiki/Microservices">微服务</a>，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。<sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup></p>
<p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p>
<h3 id="服务发现">服务发现</h3>
<p>像 <a href="https://www.consul.io/docs/index.html">Consul</a>，<a href="https://coreos.com/etcd/docs/latest">Etcd</a> 和 <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper">Zookeeper</a> 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。<a href="https://www.consul.io/intro/getting-started/checks.html">Health checks</a> 可以帮助确认服务的完整性和是否经常使用一个 <a href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEhttp">HTTP</a> 路径。Consul 和 Etcd 都有一个内建的 <a href="#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8">key-value 存储</a> 用来存储配置信息和其他的共享信息。</p>
<h3 id="不利之处应用层">不利之处：应用层</h3>
<ul>
<li>添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。</li>
<li>微服务会增加部署和运营的复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-9">来源及延伸阅读</h3>
<ul>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale">可缩放系统构架介绍</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview">破解系统设计面试</a></li>
<li><a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">面向服务架构</a></li>
<li><a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper">Zookeeper 介绍</a></li>
<li><a href="https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/">构建微服务，你所需要知道的一切</a></li>
</ul>
<h2 id="数据库">数据库</h2>
<p align="center">
  <img src="http://i.imgur.com/Xkm5CXz.png">
  <br/>
  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU">资料来源：扩展你的用户数到第一个一千万</a></strong>
</p>
<h3 id="关系型数据库管理系统rdbms">关系型数据库管理系统（RDBMS）</h3>
<p>像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p>
<blockquote>
<p>校对注：这里作者 SQL 可能指的是 MySQL</p>
</blockquote>
<p><strong>ACID</strong> 用来描述关系型数据库<a href="https://en.wikipedia.org/wiki/Database_transaction">事务</a>的特性。</p>
<ul>
<li><strong>原子性</strong> - 每个事务内部所有操作要么全部完成，要么全部不完成。</li>
<li><strong>一致性</strong> - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li>
<li><strong>隔离性</strong> - 并发执行事务的结果与顺序执行事务的结果相同。</li>
<li><strong>持久性</strong> - 事务提交后，对系统的影响是永久的。</li>
</ul>
<p>关系型数据库扩展包括许多技术：<strong>主从复制</strong>、<strong>主主复制</strong>、<strong>联合</strong>、<strong>分片</strong>、<strong>非规范化</strong>和 <strong>SQL调优</strong>。</p>
<p align="center">
  <img src="http://i.imgur.com/C9ioGtn.png">
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<h4 id="主从复制">主从复制</h4>
<p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p>
<h5 id="不利之处主从复制">不利之处：主从复制</h5>
<ul>
<li>将从库提升为主库需要额外的逻辑。</li>
<li>参考<a href="#%E4%B8%8D%E5%88%A9%E4%B9%8B%E5%A4%84%E5%A4%8D%E5%88%B6">不利之处：复制</a>中，主从复制和主主复制<strong>共同</strong>的问题。</li>
</ul>
<p align="center">
  <img src="http://i.imgur.com/krAHLGg.png">
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<h4 id="主主复制">主主复制</h4>
<p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p>
<h5 id="不利之处-主主复制">不利之处： 主主复制</h5>
<ul>
<li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li>
<li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li>
<li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li>
<li>参考<a href="#%E4%B8%8D%E5%88%A9%E4%B9%8B%E5%A4%84%E5%A4%8D%E5%88%B6">不利之处：复制</a>中，主从复制和主主复制<strong>共同</strong>的问题。</li>
</ul>
<h5 id="不利之处复制">不利之处：复制</h5>
<ul>
<li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li>
<li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li>
<li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li>
<li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li>
<li>复制意味着更多的硬件和额外的复杂度。</li>
</ul>
<h5 id="来源及延伸阅读-10">来源及延伸阅读</h5>
<ul>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">扩展性，可用性，稳定性模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multi-master_replication">多主复制</a></li>
</ul>
<h4 id="联合">联合</h4>
<p align="center">
  <img src="http://i.imgur.com/U3qV33e.png">
  <br/>
  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU">资料来源：扩展你的用户数到第一个一千万</a></strong>
</p>
<p>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：<strong>论坛</strong>、<strong>用户</strong>和<strong>产品</strong>，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<h5 id="不利之处联合">不利之处：联合</h5>
<ul>
<li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li>
<li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li>
<li>用 <a href="http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers">server link</a> 从两个库联结数据更复杂。</li>
<li>联合需要更多的硬件和额外的复杂度。</li>
</ul>
<h5 id="来源及延伸阅读联合">来源及延伸阅读：联合</h5>
<ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU">扩展你的用户数到第一个一千万</a></li>
</ul>
<h4 id="分片">分片</h4>
<p align="center">
  <img src="http://i.imgur.com/wU8x5Id.png">
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p>
<p>类似<a href="#%E8%81%94%E5%90%88">联合</a>的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p>
<h5 id="不利之处分片">不利之处：分片</h5>
<ul>
<li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li>
<li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。
<ul>
<li>再平衡会引入额外的复杂度。基于<a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html">一致性哈希</a>的分片算法可以减少这种情况。</li>
</ul>
</li>
<li>联结多个分片的数据操作更复杂。</li>
<li>分片需要更多的硬件和额外的复杂度。</li>
</ul>
<h4 id="来源及延伸阅读分片">来源及延伸阅读：分片</h4>
<ul>
<li><a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html">分片时代来临</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shard_(database_architecture)">数据库分片架构</a></li>
<li><a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html">一致性哈希</a></li>
</ul>
<h4 id="非规范化">非规范化</h4>
<p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 <a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a> 和 Oracle 支持<a href="https://en.wikipedia.org/wiki/Materialized_view">物化视图</a>，可以处理冗余信息存储和保证冗余副本一致。</p>
<p>当数据使用诸如<a href="#%E8%81%94%E5%90%88">联合</a>和<a href="#%E5%88%86%E7%89%87">分片</a>等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p>
<p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p>
<h5 id="不利之处非规范化">不利之处：非规范化</h5>
<ul>
<li>数据会冗余。</li>
<li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li>
<li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li>
</ul>
<h5 id="来源及延伸阅读非规范化">来源及延伸阅读：非规范化</h5>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Denormalization">非规范化</a></li>
</ul>
<h4 id="sql-调优">SQL 调优</h4>
<p>SQL 调优是一个范围很广的话题，有很多相关的<a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=sql+tuning">书</a>可以作为参考。</p>
<p>利用<strong>基准测试</strong>和<strong>性能分析</strong>来模拟和发现系统瓶颈很重要。</p>
<ul>
<li><strong>基准测试</strong> - 用 <a href="http://httpd.apache.org/docs/2.2/programs/ab.html">ab</a> 等工具模拟高负载情况。</li>
<li><strong>性能分析</strong> - 通过启用如<a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">慢查询日志</a>等工具来辅助追踪性能问题。</li>
</ul>
<p>基准测试和性能分析可能会指引你到以下优化方案。</p>
<h5 id="改进模式">改进模式</h5>
<ul>
<li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li>
<li>使用 <code>CHAR</code> 类型存储固定长度的字段，不要用 <code>VARCHAR</code>。
<ul>
<li><code>CHAR</code> 在快速、随机访问时效率很高。如果使用 <code>VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li>
</ul>
</li>
<li>使用 <code>TEXT</code> 类型存储大块的文本，例如博客正文。<code>TEXT</code> 还允许布尔搜索。使用 <code>TEXT</code> 字段需要在磁盘上存储一个用于定位文本块的指针。</li>
<li>使用 <code>INT</code> 类型存储高达 2^32 或 40 亿的较大数字。</li>
<li>使用 <code>DECIMAL</code> 类型存储货币可以避免浮点数表示错误。</li>
<li>避免使用 <code>BLOBS</code> 存储对象，存储存放对象的位置。</li>
<li><code>VARCHAR(255)</code> 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li>
<li>在适用场景中设置 <code>NOT NULL</code> 约束来<a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search">提高搜索性能</a>。</li>
</ul>
<h5 id="使用正确的索引">使用正确的索引</h5>
<ul>
<li>你正查询（<code>SELECT</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>JOIN</code>）的列如果用了索引会更快。</li>
<li>索引通常表示为自平衡的 <a href="https://en.wikipedia.org/wiki/B-tree">B 树</a>，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li>
<li>设置索引，会将数据存在内存中，占用了更多内存空间。</li>
<li>写入操作会变慢，因为索引需要被更新。</li>
<li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li>
</ul>
<h5 id="避免高成本的联结操作">避免高成本的联结操作</h5>
<ul>
<li>有性能需要，可以进行非规范化。</li>
</ul>
<h5 id="分割数据表">分割数据表</h5>
<ul>
<li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li>
</ul>
<h5 id="调优查询缓存">调优查询缓存</h5>
<ul>
<li>在某些情况下，<a href="http://dev.mysql.com/doc/refman/5.7/en/query-cache">查询缓存</a>可能会导致<a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/">性能问题</a>。</li>
</ul>
<h5 id="来源及延伸阅读-11">来源及延伸阅读</h5>
<ul>
<li><a href="http://20bits.com/article/10-tips-for-optimizing-mysql-queries-that-dont-suck">MySQL 查询优化小贴士</a></li>
<li><a href="http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l">为什么 VARCHAR(255) 很常见？</a></li>
<li><a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search">Null 值是如何影响数据库性能的？</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">慢查询日志</a></li>
</ul>
<h3 id="nosql">NoSQL</h3>
<p>NoSQL 是<strong>键-值数据库</strong>、<strong>文档型数据库</strong>、<strong>列型数据库</strong>或<strong>图数据库</strong>的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持<a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致</a>。</p>
<p><strong>BASE</strong> 通常被用于描述 NoSQL 数据库的特性。相比 <a href="#cap-%E7%90%86%E8%AE%BA">CAP 理论</a>，BASE 强调可用性超过一致性。</p>
<ul>
<li><strong>基本可用</strong> - 系统保证可用性。</li>
<li><strong>软状态</strong> - 即使没有输入，系统状态也可能随着时间变化。</li>
<li><strong>最终一致性</strong> - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li>
</ul>
<p>除了在 <a href="#sql-%E8%BF%98%E6%98%AF-nosql">SQL 还是 NoSQL</a> 之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下 <strong>键-值存储</strong>、<strong>文档型存储</strong>、<strong>列型存储</strong>和<strong>图存储</strong>数据库。</p>
<h4 id="键-值存储">键-值存储</h4>
<blockquote>
<p>抽象模型：哈希表</p>
</blockquote>
<p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按<a href="https://en.wikipedia.org/wiki/Lexicographical_order">字典顺序</a>维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p>
<p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p>
<p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p>
<h4 id="来源及延伸阅读-12">来源及延伸阅读</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Key-value_database">键-值数据库</a></li>
<li><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or">键-值存储的劣势</a></li>
<li><a href="http://qnimate.com/overview-of-redis-architecture/">Redis 架构</a></li>
<li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/">Memcached 架构</a></li>
</ul>
<h4 id="文档类型存储">文档类型存储</h4>
<blockquote>
<p>抽象模型：将文档作为值的键-值存储</p>
</blockquote>
<p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p>
<p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p>
<p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p>
<p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p>
<h4 id="来源及延伸阅读文档类型存储">来源及延伸阅读：文档类型存储</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Document-oriented_database">面向文档的数据库</a></li>
<li><a href="https://www.mongodb.com/mongodb-architecture">MongoDB 架构</a></li>
<li><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/">CouchDB 架构</a></li>
<li><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up">Elasticsearch 架构</a></li>
</ul>
<h4 id="列型存储">列型存储</h4>
<p align="center">
  <img src="http://i.imgur.com/n16iOGk.png">
  <br/>
  <strong><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html">资料来源: SQL 和 NoSQL，一个简短的历史</a></strong>
</p>
<blockquote>
<p>抽象模型：嵌套的 <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p>
</blockquote>
<p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p>
<p>Google 发布了第一个列型存储数据库 <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">Bigtable</a>，它影响了 Hadoop 生态系统中活跃的开源数据库 <a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture">HBase</a> 和 Facebook 的 <a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html">Cassandra</a>。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p>
<p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p>
<h5 id="来源及延伸阅读列型存储">来源及延伸阅读：列型存储</h5>
<ul>
<li><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html">SQL 与 NoSQL 简史</a></li>
<li><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">BigTable 架构</a></li>
<li><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture">Hbase 架构</a></li>
<li><a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html">Cassandra 架构</a></li>
</ul>
<h4 id="图数据库">图数据库</h4>
<p align="center">
  <img src="http://i.imgur.com/fNcl65g.png">
  <br/>
  <strong><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png">资料来源：图数据库</a></strong>
</p>
<blockquote>
<p>抽象模型： 图</p>
</blockquote>
<p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p>
<p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 <a href="#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBrest">REST API</a> 访问。</p>
<h5 id="相关资源和延伸阅读图">相关资源和延伸阅读：图</h5>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database">图数据库</a></li>
<li><a href="https://neo4j.com/">Neo4j</a></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb">FlockDB</a></li>
</ul>
<h4 id="来源及延伸阅读nosql">来源及延伸阅读：NoSQL</h4>
<ul>
<li><a href="http://stackoverflow.com/questions/3342497/explanation-of-base-terminology">数据库术语解释</a></li>
<li><a href="https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq">NoSQL 数据库 - 调查及决策指南</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database">可扩展性</a></li>
<li><a href="https://www.youtube.com/watch?v=qI_g07C_Q5I">NoSQL 介绍</a></li>
<li><a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html">NoSQL 模式</a></li>
</ul>
<h3 id="sql-还是-nosql">SQL 还是 NoSQL</h3>
<p align="center">
  <img src="http://i.imgur.com/wXGqG5f.png">
  <br/>
  <strong><a href="https://www.infoq.com/articles/Transition-RDBMS-NoSQL/">资料来源：从 RDBMS 转换到 NoSQL</a></strong>
</p>
<p>选取 <strong>SQL</strong> 的原因:</p>
<ul>
<li>结构化数据</li>
<li>严格的模式</li>
<li>关系型数据</li>
<li>需要复杂的联结操作</li>
<li>事务</li>
<li>清晰的扩展模式</li>
<li>既有资源更丰富：开发者、社区、代码库、工具等</li>
<li>通过索引进行查询非常快</li>
</ul>
<p>选取 <strong>NoSQL</strong> 的原因：</p>
<ul>
<li>半结构化数据</li>
<li>动态或灵活的模式</li>
<li>非关系型数据</li>
<li>不需要复杂的联结操作</li>
<li>存储 TB （甚至 PB）级别的数据</li>
<li>高数据密集的工作负载</li>
<li>IOPS 高吞吐量</li>
</ul>
<p>适合 NoSQL 的示例数据：</p>
<ul>
<li>埋点数据和日志数据</li>
<li>排行榜或者得分数据</li>
<li>临时数据，如购物车</li>
<li>频繁访问的（“热”）表</li>
<li>元数据／查找表</li>
</ul>
<h5 id="来源及延伸阅读sql-或-nosql">来源及延伸阅读：SQL 或 NoSQL</h5>
<ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU">扩展你的用户数到第一个千万</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/">SQL 和 NoSQL 的不同</a></li>
</ul>
<h2 id="缓存">缓存</h2>
<p align="center">
  <img src="http://i.imgur.com/Q6z24La.png">
  <br/>
  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">资料来源：可扩展的系统设计模式</a></strong>
</p>
<p>缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。</p>
<p>数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。</p>
<h3 id="客户端缓存">客户端缓存</h3>
<p>缓存可以位于客户端（操作系统或者浏览器），<a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">服务端</a>或者不同的缓存层。</p>
<h3 id="cdn-缓存">CDN 缓存</h3>
<p><a href="#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9Ccdn">CDN</a> 也被视为一种缓存。</p>
<h3 id="web-服务器缓存">Web 服务器缓存</h3>
<p><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">反向代理</a>和缓存（比如 <a href="https://www.varnish-cache.org/">Varnish</a>）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。</p>
<h3 id="数据库缓存">数据库缓存</h3>
<p>数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>
<h3 id="应用缓存">应用缓存</h3>
<p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">least recently used (LRU)</a> 的<a href="https://en.wikipedia.org/wiki/Cache_algorithms">缓存无效算法</a>可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>
<p>Redis 有下列附加功能：</p>
<ul>
<li>持久性选项</li>
<li>内置数据结构比如有序集合和列表</li>
</ul>
<p>有多个缓存级别，分为两大类：<strong>数据库查询</strong>和<strong>对象</strong>：</p>
<ul>
<li>行级别</li>
<li>查询级别</li>
<li>完整的可序列化对象</li>
<li>完全渲染的 HTML</li>
</ul>
<p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p>
<h3 id="数据库查询级别的缓存">数据库查询级别的缓存</h3>
<p>当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：</p>
<ul>
<li>很难用复杂的查询删除已缓存结果。</li>
<li>如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。</li>
</ul>
<h3 id="对象级别的缓存">对象级别的缓存</h3>
<p>将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：</p>
<ul>
<li>如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。</li>
<li>允许异步处理：workers 通过使用最新的缓存对象来组装对象。</li>
</ul>
<p>建议缓存的内容：</p>
<ul>
<li>用户会话</li>
<li>完全渲染的 Web 页面</li>
<li>活动流</li>
<li>用户图数据</li>
</ul>
<h3 id="何时更新缓存">何时更新缓存</h3>
<p>由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。</p>
<h4 id="缓存模式">缓存模式</h4>
<p align="center">
  <img src="http://i.imgur.com/ONjORqk.png">
  <br/>
  <strong><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast">资料来源：从缓存到内存数据网格</a></strong>
</p>
<p>应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：</p>
<ul>
<li>在缓存中查找记录，如果所需数据不在缓存中</li>
<li>从数据库中加载所需内容</li>
<li>将查找到的结果存储到缓存中</li>
<li>返回所需内容</li>
</ul>
<pre><code>def get_user(self, user_id):
    user = cache.get(&quot;user.{0}&quot;, user_id)
    if user is None:
        user = db.query(&quot;SELECT * FROM users WHERE user_id = {0}&quot;, user_id)
        if user is not None:
            key = &quot;user.{0}&quot;.format(user_id)
            cache.set(key, json.dumps(user))
    return user
</code></pre>
<p><a href="https://memcached.org/">Memcached</a> 通常用这种方式使用。</p>
<p>添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。</p>
<h5 id="缓存的缺点">缓存的缺点：</h5>
<ul>
<li>请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。</li>
<li>如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置 TTL 强制更新缓存或者直写模式来缓解这种情况。</li>
<li>当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。</li>
</ul>
<h4 id="直写模式">直写模式</h4>
<p align="center">
  <img src="http://i.imgur.com/0vBc0hN.png">
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<p>应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p>
<ul>
<li>应用向缓存中添加/更新数据</li>
<li>缓存同步地写入数据存储</li>
<li>返回所需内容</li>
</ul>
<p>应用代码：</p>
<pre><code>set_user(12345, {&quot;foo&quot;:&quot;bar&quot;})
</code></pre>
<p>缓存代码：</p>
<pre><code>def set_user(user_id, values):
    user = db.query(&quot;UPDATE Users WHERE id = {0}&quot;, user_id, values)
    cache.set(user_id, user)
</code></pre>
<p>由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。</p>
<h5 id="直写模式的缺点">直写模式的缺点：</h5>
<ul>
<li>由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。</li>
<li>写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。</li>
</ul>
<h4 id="回写模式">回写模式</h4>
<p align="center">
  <img src="http://i.imgur.com/rgSrvjG.png">
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<p>在回写模式中，应用执行以下操作：</p>
<ul>
<li>在缓存中增加或者更新条目</li>
<li>异步写入数据，提高写入性能。</li>
</ul>
<h5 id="回写模式的缺点">回写模式的缺点：</h5>
<ul>
<li>缓存可能在其内容成功存储之前丢失数据。</li>
<li>执行直写模式比缓存或者回写模式更复杂。</li>
</ul>
<h4 id="刷新">刷新</h4>
<p align="center">
  <img src="http://i.imgur.com/kxtjqgE.png">
  <br/>
  <strong><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>资料来源：从缓存到内存数据网格</a></strong>
</p>
<p>你可以将缓存配置成在到期之前自动刷新最近访问过的内容。</p>
<p>如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。</p>
<h5 id="刷新的缺点">刷新的缺点：</h5>
<ul>
<li>不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。</li>
</ul>
<h3 id="缓存的缺点-2">缓存的缺点：</h3>
<ul>
<li>需要保持缓存和真实数据源之间的一致性，比如数据库根据<a href="https://en.wikipedia.org/wiki/Cache_algorithms">缓存无效</a>。</li>
<li>需要改变应用程序比如增加 Redis 或者 memcached。</li>
<li>无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。</li>
</ul>
<h3 id="相关资源和延伸阅读-2">相关资源和延伸阅读</h3>
<ul>
<li><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast">从缓存到内存数据</a></li>
<li><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">可扩展系统设计模式</a></li>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/">可缩放系统构架介绍</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">可扩展性，可用性，稳定性和模式</a></li>
<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache">可扩展性</a></li>
<li><a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html">AWS ElastiCache 策略</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cache_(computing)">维基百科</a></li>
</ul>
<h2 id="异步">异步</h2>
<p align="center">
  <img src="http://i.imgur.com/54GYsSx.png">
  <br/>
  <strong><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>资料来源：可缩放系统构架介绍</a></strong>
</p>
<p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。</p>
<h3 id="消息队列">消息队列</h3>
<p>消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：</p>
<ul>
<li>应用程序将作业发布到队列，然后通知用户作业状态</li>
<li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成</li>
</ul>
<p>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</p>
<p><strong>Redis</strong> 是一个令人满意的简单的消息代理，但是消息有可能会丢失。</p>
<p><strong>RabbitMQ</strong> 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。</p>
<p><strong>Amazon SQS</strong> 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。</p>
<h3 id="任务队列">任务队列</h3>
<p>任务队列接收任务及其相关数据，运行它们，然后传递其结果。 它们可以支持调度，并可用于在后台运行计算密集型作业。</p>
<p><strong>Celery</strong> 支持调度，主要是用 Python 开发的。</p>
<h3 id="背压">背压</h3>
<p>如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。<a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html">背压</a>可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是<a href="https://en.wikipedia.org/wiki/Exponential_backoff">指数退避</a>。</p>
<h3 id="异步的缺点">异步的缺点：</h3>
<ul>
<li>简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。</li>
</ul>
<h3 id="相关资源和延伸阅读-3">相关资源和延伸阅读</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=1KRYH75wgy4">这是一个数字游戏</a></li>
<li><a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html">超载时应用背压</a></li>
<li><a href="https://en.wikipedia.org/wiki/Little%27s_law">利特尔法则</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function">消息队列与任务队列有什么区别？</a></li>
</ul>
<h2 id="通讯">通讯</h2>
<p align="center">
  <img src="http://i.imgur.com/5KeocQs.jpg">
  <br/>
  <strong><a href=http://www.escotal.com/osilayer.html>资料来源：OSI 7层模型</a></strong>
</p>
<h3 id="超文本传输协议http">超文本传输协议（HTTP）</h3>
<p>HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。</p>
<p>一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>描述</th>
<th>*幂等</th>
<th>安全性</th>
<th>可缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>读取资源</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源或触发处理数据的进程</td>
<td>No</td>
<td>No</td>
<td>Yes，如果回应包含刷新信息</td>
</tr>
<tr>
<td>PUT</td>
<td>创建或替换资源</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新资源</td>
<td>No</td>
<td>No</td>
<td>Yes，如果回应包含刷新信息</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p><strong>多次执行不会产生不同的结果</strong>。</p>
<p>HTTP 是依赖于较低级协议（如 <strong>TCP</strong> 和 <strong>UDP</strong>）的应用层协议。</p>
<h4 id="来源及延伸阅读http">来源及延伸阅读：HTTP</h4>
<ul>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol">README</a>    +</li>
<li><a href="https://www.nginx.com/resources/glossary/http/">HTTP 是什么？</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol">HTTP 和 TCP 的区别</a></li>
<li><a href="https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1">PUT 和 PATCH的区别</a></li>
</ul>
<h3 id="传输控制协议tcp">传输控制协议（TCP）</h3>
<p align="center">
  <img src="http://i.imgur.com/JdAsdvG.jpg">
  <br/>
  <strong><a href="http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/">资料来源：如何制作多人游戏</a></strong>
</p>
<p>TCP 是通过 <a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP 网络</a>的面向连接的协议。 使用<a href="https://en.wikipedia.org/wiki/Handshaking">握手</a>建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：</p>
<ul>
<li>每个数据包的序列号和<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation">校验码</a>。</li>
<li><a href="https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)">确认包</a>和自动重传</li>
</ul>
<p>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行<a href="https://en.wikipedia.org/wiki/Flow_control_(data)">流量控制</a>和<a href="https://en.wikipedia.org/wiki/Network_congestion#Congestion_control">拥塞控制</a>。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</p>
<p>为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个 <a href="#memcached">memcached</a> 服务器。<a href="https://en.wikipedia.org/wiki/Connection_pool">连接池</a> 可以帮助除了在适用的情况下切换到 UDP。</p>
<p>TCP  对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="用户数据报协议udp">用户数据报协议（UDP）</h3>
<p align="center">
  <img src="http://i.imgur.com/yzDrJtA.jpg">
  <br/>
  <strong><a href="http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1">资料来源：如何制作多人游戏</a></strong>
</p>
<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h4 id="来源及延伸阅读tcp-与-udp">来源及延伸阅读：TCP 与 UDP</h4>
<ul>
<li><a href="http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/">游戏编程的网络</a></li>
<li><a href="http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/">TCP 与 UDP 的关键区别</a></li>
<li><a href="http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp">TCP 与 UDP 的不同</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">传输控制协议</a></li>
<li><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">用户数据报协议</a></li>
<li><a href="http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf">Memcache 在 Facebook 的扩展</a></li>
</ul>
<h3 id="远程过程调用协议rpc">远程过程调用协议（RPC）</h3>
<p align="center">
  <img src="http://i.imgur.com/iF4Mkb5.png">
  <br/>
  <strong><a href="http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview">Source: Crack the system design interview</a></strong>
</p>
<p>在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 <a href="https://developers.google.com/protocol-buffers/">Protobuf</a>、<a href="https://thrift.apache.org/">Thrift</a> 和 <a href="https://avro.apache.org/docs/current/">Avro</a>。</p>
<p>RPC 是一个“请求-响应”协议：</p>
<ul>
<li><strong>客户端程序</strong> ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。</li>
<li><strong>客户端 stub 程序</strong> ── 将请求过程的 id 和参数打包进请求信息中。</li>
<li><strong>客户端通信模块</strong> ── 将信息从客户端发送至服务端。</li>
<li><strong>服务端通信模块</strong> ── 将接受的包传给服务端存根程序。</li>
<li><strong>服务端 stub 程序</strong> ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。</li>
</ul>
<p>RPC 调用示例：</p>
<pre><code>GET /someoperation?data=anId

POST /anotheroperation
{
  &quot;data&quot;:&quot;anId&quot;;
  &quot;anotherdata&quot;: &quot;another value&quot;
}
</code></pre>
<p>RPC 专注于暴露方法。RPC 通常用于处理内部通讯的性能问题，这样你可以手动处理本地调用以更好的适应你的情况。</p>
<p>当以下情况时选择本地库（也就是 SDK）：</p>
<ul>
<li>你知道你的目标平台。</li>
<li>你想控制如何访问你的“逻辑”。</li>
<li>你想对发生在你的库中的错误进行控制。</li>
<li>性能和终端用户体验是你最关心的事。</li>
</ul>
<p>遵循 <strong>REST</strong> 的 HTTP API 往往更适用于公共 API。</p>
<h4 id="缺点rpc">缺点：RPC</h4>
<ul>
<li>RPC 客户端与服务实现捆绑地很紧密。</li>
<li>一个新的 API 必须在每一个操作或者用例中定义。</li>
<li>RPC 很难调试。</li>
<li>你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在 <a href="http://www.squid-cache.org/">Squid</a> 这样的缓存服务器上确保 <a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/">RPC 被正确缓存</a>的话可能需要一些额外的努力了。</li>
</ul>
<h3 id="表述性状态转移rest">表述性状态转移（REST）</h3>
<p>REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。</p>
<p>RESTful 接口有四条规则：</p>
<ul>
<li><strong>标志资源（HTTP 里的 URI）</strong> ── 无论什么操作都使用同一个 URI。</li>
<li><strong>表示的改变（HTTP 的动作）</strong> ── 使用动作, headers 和 body。</li>
<li><strong>可自我描述的错误信息（HTTP 中的 status code）</strong> ── 使用状态码，不要重新造轮子。</li>
<li><strong><a href="http://restcookbook.com/Basics/hateoas/">HATEOAS</a>（HTTP 中的HTML 接口）</strong> ── 你的 web 服务器应该能够通过浏览器访问。</li>
</ul>
<p>REST 请求的例子：</p>
<pre><code>GET /someresources/anId

PUT /someresources/anId
{&quot;anotherdata&quot;: &quot;another value&quot;}
</code></pre>
<p>REST 关注于暴露数据。它减少了客户端／服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，<a href="https://github.com/for-GET/know-your-http-well/blob/master/headers.md">通过 header 来表述</a>并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。</p>
<h4 id="缺点rest">缺点：REST</h4>
<ul>
<li>由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。</li>
<li>REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。</li>
<li>为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。</li>
<li>随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。</li>
</ul>
<h3 id="rpc-与-rest-比较">RPC 与 REST 比较</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>RPC</th>
<th>REST</th>
</tr>
</thead>
<tbody>
<tr>
<td>注册</td>
<td><strong>POST</strong> /signup</td>
<td><strong>POST</strong> /persons</td>
</tr>
<tr>
<td>注销</td>
<td><strong>POST</strong> /resign<br/>{<br/>&quot;personid&quot;: &quot;1234&quot;<br/>}</td>
<td><strong>DELETE</strong> /persons/1234</td>
</tr>
<tr>
<td>读取用户信息</td>
<td><strong>GET</strong> /readPerson?personid=1234</td>
<td><strong>GET</strong> /persons/1234</td>
</tr>
<tr>
<td>读取用户物品列表</td>
<td><strong>GET</strong> /readUsersItemsList?personid=1234</td>
<td><strong>GET</strong> /persons/1234/items</td>
</tr>
<tr>
<td>向用户物品列表添加一项</td>
<td><strong>POST</strong> /addItemToUsersItemsList<br/>{<br/>&quot;personid&quot;: &quot;1234&quot;;<br/>&quot;itemid&quot;: &quot;456&quot;<br/>}</td>
<td><strong>POST</strong> /persons/1234/items<br/>{<br/>&quot;itemid&quot;: &quot;456&quot;<br/>}</td>
</tr>
<tr>
<td>更新一个物品</td>
<td><strong>POST</strong> /modifyItem<br/>{<br/>&quot;itemid&quot;: &quot;456&quot;;<br/>&quot;key&quot;: &quot;value&quot;<br/>}</td>
<td><strong>PUT</strong> /items/456<br/>{<br/>&quot;key&quot;: &quot;value&quot;<br/>}</td>
</tr>
<tr>
<td>删除一个物品</td>
<td><strong>POST</strong> /removeItem<br/>{<br/>&quot;itemid&quot;: &quot;456&quot;<br/>}</td>
<td><strong>DELETE</strong> /items/456</td>
</tr>
</tbody>
</table>
<p align="center">
  <strong><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc">资料来源：你真的知道你为什么更喜欢 REST 而不是 RPC 吗</a></strong>
</p>
<h4 id="来源及延伸阅读rest-与-rpc">来源及延伸阅读：REST 与 RPC</h4>
<ul>
<li><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/">你真的知道你为什么更喜欢 REST 而不是 RPC 吗</a></li>
<li><a href="http://programmers.stackexchange.com/a/181186">什么时候 RPC 比 REST 更合适？</a></li>
<li><a href="http://stackoverflow.com/questions/15056878/rest-vs-json-rpc">REST vs JSON-RPC</a></li>
<li><a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/">揭开 RPC 和 REST 的神秘面纱</a></li>
<li><a href="https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs">使用 REST 的缺点是什么</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview">破解系统设计面试</a></li>
<li><a href="https://code.facebook.com/posts/1468950976659943/">Thrift</a></li>
<li><a href="http://arstechnica.com/civis/viewtopic.php?t=1190508">为什么在内部使用 REST 而不是 RPC</a></li>
</ul>
<h2 id="安全">安全</h2>
<p>这一部分需要更多内容。<a href="#%E8%B4%A1%E7%8C%AE">一起来吧</a>！</p>
<p>安全是一个宽泛的话题。除非你有相当的经验、安全方面背景或者正在申请的职位要求安全知识，你不需要了解安全基础知识以外的内容：</p>
<ul>
<li>在运输和等待过程中加密</li>
<li>对所有的用户输入和从用户那里发来的参数进行处理以防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> 和 <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL 注入</a>。</li>
<li>使用参数化的查询来防止 SQL 注入。</li>
<li>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小权限原则</a>。</li>
</ul>
<h3 id="来源及延伸阅读-13">来源及延伸阅读</h3>
<ul>
<li><a href="https://github.com/FallibleInc/security-guide-for-developers">为开发者准备的安全引导</a></li>
<li><a href="https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet">OWASP top ten</a></li>
</ul>
<h2 id="附录">附录</h2>
<p>一些时候你会被要求做出保守估计。比如，你可能需要估计从磁盘中生成 100 张图片的缩略图需要的时间或者一个数据结构需要多少的内存。<strong>2 的次方表</strong>和<strong>每个开发者都需要知道的一些时间数据</strong>（译注：OSChina 上有这篇文章的<a href="https://www.oschina.net/news/30009/every-programmer-should-know">译文</a>）都是一些很方便的参考资料。</p>
<h3 id="2-的次方表">2 的次方表</h3>
<pre><code>Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
</code></pre>
<h4 id="来源及延伸阅读-14">来源及延伸阅读</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Power_of_two">2 的次方</a></li>
</ul>
<h3 id="每个程序员都应该知道的延迟数">每个程序员都应该知道的延迟数</h3>
<pre><code>Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                          100   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
</code></pre>
<p>基于上述数字的指标：</p>
<ul>
<li>从磁盘以 30 MB/s 的速度顺序读取</li>
<li>以 100 MB/s 从 1 Gbps 的以太网顺序读取</li>
<li>从 SSD 以 1 GB/s 的速度读取</li>
<li>以 4 GB/s 的速度从主存读取</li>
<li>每秒能绕地球 6-7 圈</li>
<li>数据中心内每秒有 2,000 次往返</li>
</ul>
<h4 id="延迟数可视化">延迟数可视化</h4>
<figure data-type="image" tabindex="10"><img src="https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67" alt="" loading="lazy"></figure>
<h4 id="来源及延伸阅读-15">来源及延伸阅读</h4>
<ul>
<li><a href="https://gist.github.com/jboner/2841832">每个程序员都应该知道的延迟数 — 1</a></li>
<li><a href="https://gist.github.com/hellerbarde/2843375">每个程序员都应该知道的延迟数 — 2</a></li>
<li><a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf">关于建设大型分布式系统的的设计方案、课程和建议</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf">关于建设大型可拓展分布式系统的软件工程咨询</a></li>
</ul>
<h3 id="其它的系统设计面试题">其它的系统设计面试题</h3>
<blockquote>
<p>常见的系统设计面试问题，给出了如何解决的方案链接</p>
</blockquote>
<table>
<thead>
<tr>
<th>问题</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计类似于 Dropbox 的文件同步服务</td>
<td><a href="https://www.youtube.com/watch?v=PE4gwstWhmc">youtube.com</a></td>
</tr>
<tr>
<td>设计类似于 Google 的搜索引擎</td>
<td><a href="http://queue.acm.org/detail.cfm?id=988407">queue.acm.org</a><br/><a href="http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search">stackexchange.com</a><br/><a href="http://www.ardendertat.com/2012/01/11/implementing-search-engines/">ardendertat.com</a><br><a href="http://infolab.stanford.edu/~backrub/google.html">stanford.edu</a></td>
</tr>
<tr>
<td>设计类似于 Google 的可扩展网络爬虫</td>
<td><a href="https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch">quora.com</a></td>
</tr>
<tr>
<td>设计 Google 文档</td>
<td><a href="https://code.google.com/p/google-mobwrite/">code.google.com</a><br/><a href="https://neil.fraser.name/writing/sync/">neil.fraser.name</a></td>
</tr>
<tr>
<td>设计类似 Redis 的建值存储</td>
<td><a href="http://www.slideshare.net/dvirsky/introduction-to-redis">slideshare.net</a></td>
</tr>
<tr>
<td>设计类似 Memcached 的缓存系统</td>
<td><a href="http://www.slideshare.net/oemebamo/introduction-to-memcached">slideshare.net</a></td>
</tr>
<tr>
<td>设计类似亚马逊的推荐系统</td>
<td><a href="http://tech.hulu.com/blog/2011/09/19/recommendation-system.html">hulu.com</a><br/><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf">ijcai13.org</a></td>
</tr>
<tr>
<td>设计类似 Bitly 的短链接系统</td>
<td><a href="http://n00tc0d3r.blogspot.com/">n00tc0d3r.blogspot.com</a></td>
</tr>
<tr>
<td>设计类似 WhatsApp 的聊天应用</td>
<td><a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html">highscalability.com</a></td>
</tr>
<tr>
<td>设计类似 Instagram 的图片分享系统</td>
<td><a href="http://highscalability.com/flickr-architecture">highscalability.com</a><br/><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html">highscalability.com</a></td>
</tr>
<tr>
<td>设计 Facebook 的新闻推荐方法</td>
<td><a href="http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed">quora.com</a><br/><a href="http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed">quora.com</a><br/><a href="http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture">slideshare.net</a></td>
</tr>
<tr>
<td>设计 Facebook 的时间线系统</td>
<td><a href="https://www.facebook.com/note.php?note_id=10150468255628920">facebook.com</a><br/><a href="http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html">highscalability.com</a></td>
</tr>
<tr>
<td>设计 Facebook 的聊天系统</td>
<td><a href="http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf">erlang-factory.com</a><br/><a href="https://www.facebook.com/note.php?note_id=14218138919&amp;id=9445547199&amp;index=0">facebook.com</a></td>
</tr>
<tr>
<td>设计类似 Facebook 的图表搜索系统</td>
<td><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920">facebook.com</a><br/><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920">facebook.com</a><br/><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920">facebook.com</a></td>
</tr>
<tr>
<td>设计类似 CloudFlare 的内容传递网络</td>
<td><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci">cmu.edu</a></td>
</tr>
<tr>
<td>设计类似 Twitter 的热门话题系统</td>
<td><a href="http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/">michael-noll.com</a><br/><a href="http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/">snikolov .wordpress.com</a></td>
</tr>
<tr>
<td>设计一个随机 ID 生成系统</td>
<td><a href="https://blog.twitter.com/2010/announcing-snowflake">blog.twitter.com</a><br/><a href="https://github.com/twitter/snowflake/">github.com</a></td>
</tr>
<tr>
<td>返回一定时间段内次数前 k 高的请求</td>
<td><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf">ucsb.edu</a><br/><a href="http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf">wpi.edu</a></td>
</tr>
<tr>
<td>设计一个数据源于多个数据中心的服务系统</td>
<td><a href="http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html">highscalability.com</a></td>
</tr>
<tr>
<td>设计一个多人网络卡牌游戏</td>
<td><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html">indieflashblog.com</a><br/><a href="http://buildnewgames.com/real-time-multiplayer/">buildnewgames.com</a></td>
</tr>
<tr>
<td>设计一个垃圾回收系统</td>
<td><a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/">stuffwithstuff.com</a><br/><a href="http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf">washington.edu</a></td>
</tr>
<tr>
<td>添加更多的系统设计问题</td>
<td><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></td>
</tr>
</tbody>
</table>
<h3 id="真实架构">真实架构</h3>
<blockquote>
<p>关于现实中真实的系统是怎么设计的文章。</p>
</blockquote>
<p align="center">
  <img src="http://i.imgur.com/TcUo2fw.png">
  <br/>
  <strong><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability">Source: Twitter timelines at scale</a></strong>
</p>
<p><strong>不要专注于以下文章的细节，专注于以下方面：</strong></p>
<ul>
<li>发现这些文章中的共同的原则、技术和模式。</li>
<li>学习每个组件解决哪些问题，什么情况下使用，什么情况下不适用</li>
<li>复习学过的文章</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>系统</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data processing</td>
<td><strong>MapReduce</strong> - Google的分布式数据处理</td>
<td><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf">research.google.com</a></td>
</tr>
<tr>
<td>Data processing</td>
<td><strong>Spark</strong> - Databricks 的分布式数据处理</td>
<td><a href="http://www.slideshare.net/AGrishchenko/apache-spark-architecture">slideshare.net</a></td>
</tr>
<tr>
<td>Data processing</td>
<td><strong>Storm</strong> - Twitter 的分布式数据处理</td>
<td><a href="http://www.slideshare.net/previa/storm-16094009">slideshare.net</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Bigtable</strong> - Google 的列式数据库</td>
<td><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">harvard.edu</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>HBase</strong> - Bigtable 的开源实现</td>
<td><a href="http://www.slideshare.net/alexbaranau/intro-to-hbase">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Cassandra</strong> - Facebook 的列式数据库</td>
<td><a href="http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>DynamoDB</strong> - Amazon 的文档数据库</td>
<td><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf">harvard.edu</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>MongoDB</strong> - 文档数据库</td>
<td><a href="http://www.slideshare.net/mdirolf/introduction-to-mongodb">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Spanner</strong> - Google 的全球分布数据库</td>
<td><a href="http://research.google.com/archive/spanner-osdi2012.pdf">research.google.com</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Memcached</strong> - 分布式内存缓存系统</td>
<td><a href="http://www.slideshare.net/oemebamo/introduction-to-memcached">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Redis</strong> - 能够持久化及具有值类型的分布式内存缓存系统</td>
<td><a href="http://www.slideshare.net/dvirsky/introduction-to-redis">slideshare.net</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>File system</td>
<td><strong>Google File System (GFS)</strong> - 分布式文件系统</td>
<td><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf">research.google.com</a></td>
</tr>
<tr>
<td>File system</td>
<td><strong>Hadoop File System (HDFS)</strong> - GFS 的开源实现</td>
<td><a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html">apache.org</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Chubby</strong> - Google 的分布式系统的低耦合锁服务</td>
<td><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf">research.google.com</a></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Dapper</strong> - 分布式系统跟踪基础设施</td>
<td><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf">research.google.com</a></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Kafka</strong> - LinkedIn 的发布订阅消息系统</td>
<td><a href="http://www.slideshare.net/mumrah/kafka-talk-tri-hug">slideshare.net</a></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Zookeeper</strong> - 集中的基础架构和协调服务</td>
<td><a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper">slideshare.net</a></td>
</tr>
<tr>
<td></td>
<td>添加更多</td>
<td><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></td>
</tr>
</tbody>
</table>
<h3 id="公司的系统架构">公司的系统架构</h3>
<table>
<thead>
<tr>
<th>Company</th>
<th>Reference(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Amazon</td>
<td><a href="http://highscalability.com/amazon-architecture">Amazon 的架构</a></td>
</tr>
<tr>
<td>Cinchcast</td>
<td><a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html">每天产生 1500 小时的音频</a></td>
</tr>
<tr>
<td>DataSift</td>
<td><a href="http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html">每秒实时挖掘 120000 条 tweet</a></td>
</tr>
<tr>
<td>DropBox</td>
<td><a href="https://www.youtube.com/watch?v=PE4gwstWhmc">我们如何缩放 Dropbox</a></td>
</tr>
<tr>
<td>ESPN</td>
<td><a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html">每秒操作 100000 次</a></td>
</tr>
<tr>
<td>Google</td>
<td><a href="http://highscalability.com/google-architecture">Google 的架构</a></td>
</tr>
<tr>
<td>Instagram</td>
<td><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html">1400 万用户，达到兆级别的照片存储</a><br/><a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances">是什么在驱动 Instagram</a></td>
</tr>
<tr>
<td>Justin.tv</td>
<td><a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html">Justin.Tv 的直播广播架构</a></td>
</tr>
<tr>
<td>Facebook</td>
<td><a href="https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf">Facebook 的可扩展 memcached</a><br/><a href="https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf">TAO: Facebook 社交图的分布式数据存储</a><br/><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf">Facebook 的图片存储</a></td>
</tr>
<tr>
<td>Flickr</td>
<td><a href="http://highscalability.com/flickr-architecture">Flickr 的架构</a></td>
</tr>
<tr>
<td>Mailbox</td>
<td><a href="http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html">在 6 周内从 0 到 100 万用户</a></td>
</tr>
<tr>
<td>Pinterest</td>
<td><a href="http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html">从零到每月数十亿的浏览量</a><br/><a href="http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html">1800 万访问用户，10 倍增长，12 名员工</a></td>
</tr>
<tr>
<td>Playfish</td>
<td><a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html">月用户量 5000 万并在不断增长</a></td>
</tr>
<tr>
<td>PlentyOfFish</td>
<td><a href="http://highscalability.com/plentyoffish-architecture">PlentyOfFish 的架构</a></td>
</tr>
<tr>
<td>Salesforce</td>
<td><a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html">他们每天如何处理 13 亿笔交易</a></td>
</tr>
<tr>
<td>Stack Overflow</td>
<td><a href="http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html">Stack Overflow 的架构</a></td>
</tr>
<tr>
<td>TripAdvisor</td>
<td><a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html">40M 访问者，200M 页面浏览量，30TB 数据</a></td>
</tr>
<tr>
<td>Tumblr</td>
<td><a href="http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html">每月 150 亿的浏览量</a></td>
</tr>
<tr>
<td>Twitter</td>
<td><a href="http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster">Making Twitter 10000 percent faster</a><br/><a href="http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html">每天使用 MySQL 存储2.5亿条 tweet</a><br/><a href="http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html">150M 活跃用户，300K QPS，22 MB/S 的防火墙</a><br/><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability">可扩展时间表</a><br/><a href="https://www.youtube.com/watch?v=5cKTP36HVgI">Twitter 的大小数据</a><br/><a href="https://www.youtube.com/watch?v=z8LU0Cj6BOU">Twitter 的行为：规模超过 1 亿用户</a></td>
</tr>
<tr>
<td>Uber</td>
<td><a href="http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html">Uber 如何扩展自己的实时化市场</a></td>
</tr>
<tr>
<td>WhatsApp</td>
<td><a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html">Facebook 用 190 亿美元购买 WhatsApp 的架构</a></td>
</tr>
<tr>
<td>YouTube</td>
<td><a href="https://www.youtube.com/watch?v=w5WVu624fY8">YouTube 的可扩展性</a><br/><a href="http://highscalability.com/youtube-architecture">YouTube 的架构</a></td>
</tr>
</tbody>
</table>
<h3 id="公司工程博客">公司工程博客</h3>
<blockquote>
<p>你即将面试的公司的架构</p>
<p>你面对的问题可能就来自于同样领域</p>
</blockquote>
<ul>
<li><a href="http://nerds.airbnb.com/">Airbnb Engineering</a></li>
<li><a href="https://developer.atlassian.com/blog/">Atlassian Developers</a></li>
<li><a href="http://cloudengineering.autodesk.com/blog/">Autodesk Engineering</a></li>
<li><a href="https://aws.amazon.com/blogs/aws/">AWS Blog</a></li>
<li><a href="http://word.bitly.com/">Bitly Engineering Blog</a></li>
<li><a href="https://www.box.com/blog/engineering/">Box Blogs</a></li>
<li><a href="http://blog.cloudera.com/blog/">Cloudera Developer Blog</a></li>
<li><a href="https://tech.dropbox.com/">Dropbox Tech Blog</a></li>
<li><a href="http://engineering.quora.com/">Engineering at Quora</a></li>
<li><a href="http://www.ebaytechblog.com/">Ebay Tech Blog</a></li>
<li><a href="https://blog.evernote.com/tech/">Evernote Tech Blog</a></li>
<li><a href="http://codeascraft.com/">Etsy Code as Craft</a></li>
<li><a href="https://www.facebook.com/Engineering">Facebook Engineering</a></li>
<li><a href="http://code.flickr.net/">Flickr Code</a></li>
<li><a href="http://engineering.foursquare.com/">Foursquare Engineering Blog</a></li>
<li><a href="http://githubengineering.com/">GitHub Engineering Blog</a></li>
<li><a href="http://googleresearch.blogspot.com/">Google Research Blog</a></li>
<li><a href="https://engineering.groupon.com/">Groupon Engineering Blog</a></li>
<li><a href="https://engineering.heroku.com/">Heroku Engineering Blog</a></li>
<li><a href="http://product.hubspot.com/blog/topic/engineering">Hubspot Engineering Blog</a></li>
<li><a href="http://highscalability.com/">High Scalability</a></li>
<li><a href="http://instagram-engineering.tumblr.com/">Instagram Engineering</a></li>
<li><a href="https://software.intel.com/en-us/blogs/">Intel Software Blog</a></li>
<li><a href="https://blogs.janestreet.com/category/ocaml/">Jane Street Tech Blog</a></li>
<li><a href="http://engineering.linkedin.com/blog">LinkedIn Engineering</a></li>
<li><a href="https://engineering.microsoft.com/">Microsoft Engineering</a></li>
<li><a href="https://blogs.msdn.microsoft.com/pythonengineering/">Microsoft Python Engineering</a></li>
<li><a href="http://techblog.netflix.com/">Netflix Tech Blog</a></li>
<li><a href="https://devblog.paypal.com/category/engineering/">Paypal Developer Blog</a></li>
<li><a href="http://engineering.pinterest.com/">Pinterest Engineering Blog</a></li>
<li><a href="https://engineering.quora.com/">Quora Engineering</a></li>
<li><a href="http://www.redditblog.com/">Reddit Blog</a></li>
<li><a href="https://developer.salesforce.com/blogs/engineering/">Salesforce Engineering Blog</a></li>
<li><a href="https://slack.engineering/">Slack Engineering Blog</a></li>
<li><a href="https://labs.spotify.com/">Spotify Labs</a></li>
<li><a href="http://www.twilio.com/engineering">Twilio Engineering Blog</a></li>
<li><a href="https://engineering.twitter.com/">Twitter Engineering</a></li>
<li><a href="http://eng.uber.com/">Uber Engineering Blog</a></li>
<li><a href="http://yahooeng.tumblr.com/">Yahoo Engineering Blog</a></li>
<li><a href="http://engineeringblog.yelp.com/">Yelp Engineering Blog</a></li>
<li><a href="https://www.zynga.com/blogs/engineering">Zynga Engineering Blog</a></li>
</ul>
<h4 id="来源及延伸阅读-16">来源及延伸阅读</h4>
<ul>
<li><a href="https://github.com/kilimchoi/engineering-blogs">kilimchoi/engineering-blogs</a></li>
</ul>
<h2 id="正在完善中">正在完善中</h2>
<p>有兴趣加入添加一些部分或者帮助完善某些部分吗？<a href="#%E8%B4%A1%E7%8C%AE">加入进来吧</a>！</p>
<ul>
<li>使用 MapReduce 进行分布式计算</li>
<li>一致性哈希</li>
<li>直接存储器访问（DMA）控制器</li>
<li><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></li>
</ul>
<h2 id="致谢">致谢</h2>
<p>整个仓库都提供了证书和源</p>
<p>特别鸣谢：</p>
<ul>
<li><a href="http://www.hiredintech.com/system-design/the-system-design-process/">Hired in tech</a></li>
<li><a href="https://www.amazon.com/dp/0984782850/">Cracking the coding interview</a></li>
<li><a href="http://highscalability.com/">High scalability</a></li>
<li><a href="https://github.com/checkcheckzz/system-design-interview">checkcheckzz/system-design-interview</a></li>
<li><a href="https://github.com/shashank88/system_design">shashank88/system_design</a></li>
<li><a href="https://github.com/mmcgrana/services-engineering">mmcgrana/services-engineering</a></li>
<li><a href="https://gist.github.com/vasanthk/485d1c25737e8e72759f">System design cheat sheet</a></li>
<li><a href="http://dancres.github.io/Pages/">A distributed systems reading list</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview">Cracking the system design interview</a></li>
</ul>
<h2 id="联系方式">联系方式</h2>
<p>欢迎联系我讨论本文的不足、问题或者意见。</p>
<p>可以在我的 <a href="https://github.com/donnemartin">GitHub 主页</a>上找到我的联系方式</p>
<h2 id="许可">许可</h2>
<pre><code>Creative Commons Attribution 4.0 International License (CC BY 4.0)

http://creativecommons.org/licenses/by/4.0/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Welcome to Kingcall's GitHub Pages]]></title>
        <id>https://kingcall.github.io/post/welcome-to-kingcalls-github-pages/</id>
        <link href="https://kingcall.github.io/post/welcome-to-kingcalls-github-pages/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="博主介绍">博主介绍</h2>
<h3 id="个人简介">个人简介</h3>
<ul>
<li>博主本名刘文强，是一个来自西北偏远地区的大男孩，西北的风土人情赋予了他开朗洒脱的性情，西北的艰苦的生活赋予了他不屈不挠<br>
的吃苦精神，一生信奉的三句话：
<ol>
<li>生命不息，奋斗不止</li>
<li>栽好梧桐树，自有凤凰来</li>
<li>当你最爱的人需要你的时候，你却无能为力，是件多么可悲的事</li>
</ol>
</li>
</ul>
<blockquote>
<p>以上三句话，阐述了博主对自己，对另一半，对家人的责任，也就是博主奋斗一生的终极动力。</p>
</blockquote>
<ul>
<li>博主2012——2016年就读于长江大学，所学专业是信息与计算科学，本科期间热爱数学与计算机，在老师和学长的指导下，接触数据挖掘，<br>
参加数据挖掘比赛，最后参加全国大学生数学建模比赛，打下了深厚扎实的理论基础，最终将目光停留在了大数据技术上，从此爱上大数据<br>
无法自拔，是一枚纯粹的技发烧友。</li>
</ul>
<h3 id="工作简介">工作简介</h3>
<pre><code>2016-07到2019-5 苏宁文创（苏宁控股集团下六大子公司之一）从事大数据开发，主要工作方向是实时计算  
2019-05到2020-06 掌门一对一 大数据开发
</code></pre>
]]></content>
    </entry>
</feed>